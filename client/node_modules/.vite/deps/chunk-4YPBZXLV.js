// node_modules/@cloudinary/transformation-builder-sdk/internal/qualifier/QualifierValue.js
var QualifierValue = class {
  /**
   *
   * @param {QualifierValue | QualifierValue[] | any[] | string | number}qualifierValue
   */
  constructor(qualifierValue) {
    this.values = [];
    this.delimiter = ":";
    if (this.hasValue(qualifierValue)) {
      this.addValue(qualifierValue);
    }
  }
  /**
   * @description Joins the provided values with the provided delimiter
   */
  toString() {
    return this.values.join(this.delimiter);
  }
  /**
   * @description Checks if the provided argument has a value
   * @param {any} v
   * @private
   * @return {boolean}
   */
  hasValue(v) {
    return typeof v !== "undefined" && v !== null && v !== "";
  }
  /**
   * @desc Adds a value for the this qualifier instance
   * @param {any} value
   * @return {this}
   */
  addValue(value) {
    if (Array.isArray(value)) {
      this.values = this.values.concat(value);
    } else {
      this.values.push(value);
    }
    this.values = this.values.filter((v) => this.hasValue(v));
    return this;
  }
  /**
   * @description Sets the delimiter for this instance
   * @param delimiter
   */
  setDelimiter(delimiter) {
    this.delimiter = delimiter;
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/unsupportedError.js
var UnsupportedError = class extends Error {
  constructor(message = "Unsupported") {
    super(message);
  }
};
function createUnsupportedError(message) {
  return new UnsupportedError(message);
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/qualifierToJson.js
function qualifierToJson() {
  return this._qualifierModel || { error: createUnsupportedError(`unsupported qualifier ${this.constructor.name}`) };
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/QualifierModel.js
var QualifierModel = class {
  constructor() {
    this._qualifierModel = {};
  }
  toJson() {
    return qualifierToJson.apply(this);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/qualifier/Qualifier.js
var Qualifier = class extends QualifierModel {
  constructor(key, qualifierValue) {
    super();
    this.delimiter = "_";
    this.key = key;
    if (qualifierValue instanceof QualifierValue) {
      this.qualifierValue = qualifierValue;
    } else {
      this.qualifierValue = new QualifierValue();
      this.qualifierValue.addValue(qualifierValue);
    }
  }
  toString() {
    const { key, delimiter, qualifierValue } = this;
    return `${key}${delimiter}${qualifierValue.toString()}`;
  }
  addValue(value) {
    this.qualifierValue.addValue(value);
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/flag/FlagQualifier.js
var FlagQualifier = class extends Qualifier {
  constructor(flagType, flagValue) {
    let qualifierValue;
    if (flagValue) {
      qualifierValue = new QualifierValue([flagType, `${flagValue}`]).setDelimiter(":");
    } else {
      qualifierValue = flagType;
    }
    super("fl", qualifierValue);
    this.flagValue = flagValue;
  }
  toString() {
    return super.toString().replace(/\./, "%2E");
  }
  getFlagValue() {
    return this.flagValue;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/dataStructureUtils.js
function mapToSortedArray(map, flags) {
  const array = Array.from(map.entries());
  flags.forEach((flag) => {
    array.push(["fl", flag]);
  });
  return array.sort().map((v) => v[1]);
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/actionToJson.js
function actionToJson() {
  var _a, _b, _c;
  const actionModelIsNotEmpty = this._actionModel && Object.keys(this._actionModel).length;
  const sourceTransformationError = (_c = (_b = (_a = this._actionModel) === null || _a === void 0 ? void 0 : _a.source) === null || _b === void 0 ? void 0 : _b.transformation) === null || _c === void 0 ? void 0 : _c.error;
  if (sourceTransformationError && sourceTransformationError instanceof Error) {
    return { error: sourceTransformationError };
  }
  if (actionModelIsNotEmpty) {
    return this._actionModel;
  }
  return { error: createUnsupportedError(`unsupported action ${this.constructor.name}`) };
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/ActionModel.js
var ActionModel = class {
  constructor() {
    this._actionModel = {};
  }
  toJson() {
    return actionToJson.apply(this);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/Action.js
var Action = class extends ActionModel {
  constructor() {
    super(...arguments);
    this.qualifiers = /* @__PURE__ */ new Map();
    this.flags = [];
    this.delimiter = ",";
    this.actionTag = "";
  }
  prepareQualifiers() {
  }
  /**
   * @description Returns the custom name tag that was given to this action
   * @return {string}
   */
  getActionTag() {
    return this.actionTag;
  }
  /**
   * @description Sets the custom name tag for this action
   * @return {this}
   */
  setActionTag(tag) {
    this.actionTag = tag;
    return this;
  }
  /**
   * @description Calls toString() on all child qualifiers (implicitly by using .join()).
   * @return {string}
   */
  toString() {
    this.prepareQualifiers();
    return mapToSortedArray(this.qualifiers, this.flags).join(this.delimiter);
  }
  /**
   * @description Adds the parameter to the action.
   * @param {SDK.Qualifier} qualifier
   * @return {this}
   */
  addQualifier(qualifier) {
    if (typeof qualifier === "string") {
      const [key, value] = qualifier.toLowerCase().split("_");
      if (key === "fl") {
        this.flags.push(new FlagQualifier(value));
      } else {
        this.qualifiers.set(key, new Qualifier(key, value));
      }
    } else {
      this.qualifiers.set(qualifier.key, qualifier);
    }
    return this;
  }
  /**
   * @description Adds a flag to the current action.
   * @param {Qualifiers.Flag} flag
   * @return {this}
   */
  addFlag(flag) {
    if (typeof flag === "string") {
      this.flags.push(new FlagQualifier(flag));
    } else {
      if (flag instanceof FlagQualifier) {
        this.flags.push(flag);
      }
    }
    return this;
  }
  addValueToQualifier(qualifierKey, qualifierValue) {
    this.qualifiers.get(qualifierKey).addValue(qualifierValue);
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/toFloatAsString.js
function toFloatAsString(value) {
  const returnValue = value.toString();
  if (returnValue.match(/[A-Z]/gi)) {
    return returnValue;
  }
  if (returnValue.length > 1 && returnValue[0] === "0") {
    return returnValue;
  }
  const isNumberLike = !isNaN(parseFloat(returnValue)) && returnValue.indexOf(":") === -1;
  if (isNumberLike && returnValue.indexOf(".") === -1) {
    return `${returnValue}.0`;
  } else {
    return returnValue;
  }
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/aspectRatio/AspectRatioQualifierValue.js
var AspectRatioQualifierValue = class extends QualifierValue {
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/flag.js
function animated() {
  return new FlagQualifier("animated");
}
function animatedWebP() {
  return new FlagQualifier("awebp");
}
function clip() {
  return new FlagQualifier("clip");
}
function clipEvenOdd() {
  return new FlagQualifier("clip_evenodd");
}
function ignoreInitialAspectRatio() {
  return new FlagQualifier("ignore_aspect_ratio");
}
function lossy() {
  return new FlagQualifier("lossy");
}
function noOverflow() {
  return new FlagQualifier("no_overflow");
}
function preserveTransparency() {
  return new FlagQualifier("preserve_transparency");
}
function progressive(mode2) {
  return new FlagQualifier("progressive", mode2);
}
function regionRelative() {
  return new FlagQualifier("region_relative");
}
function relative() {
  return new FlagQualifier("relative");
}
function tiled() {
  return new FlagQualifier("tiled");
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/objectFlip.js
function objectFlip(obj) {
  const result = {};
  Object.keys(obj).forEach((key) => {
    result[obj[key]] = key;
  });
  return result;
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/internalConstants.js
var CONDITIONAL_OPERATORS = {
  "=": "eq",
  "!=": "ne",
  "<": "lt",
  ">": "gt",
  "<=": "lte",
  ">=": "gte",
  "&&": "and",
  "||": "or",
  "*": "mul",
  "/": "div",
  "+": "add",
  "-": "sub",
  "^": "pow"
};
var RESERVED_NAMES = {
  "aspect_ratio": "ar",
  "aspectRatio": "ar",
  "current_page": "cp",
  "currentPage": "cp",
  "duration": "du",
  "face_count": "fc",
  "faceCount": "fc",
  "height": "h",
  "initial_aspect_ratio": "iar",
  "initial_height": "ih",
  "initial_width": "iw",
  "initialAspectRatio": "iar",
  "initialHeight": "ih",
  "initialWidth": "iw",
  "initial_duration": "idu",
  "initialDuration": "idu",
  "page_count": "pc",
  "page_x": "px",
  "page_y": "py",
  "pageCount": "pc",
  "pageX": "px",
  "pageY": "py",
  "tags": "tags",
  "width": "w",
  "trimmed_aspect_ratio": "tar",
  "current_public_id": "cpi",
  "initial_density": "idn",
  "page_names": "pgnames"
};
var ACTION_TYPE_TO_CROP_MODE_MAP = {
  limitFit: "limit",
  limitFill: "lfill",
  minimumFit: "mfit",
  thumbnail: "thumb",
  limitPad: "lpad",
  minimumPad: "mpad"
};
var ACTION_TYPE_TO_DELIVERY_MODE_MAP = {
  colorSpace: "cs",
  dpr: "dpr",
  density: "dn",
  defaultImage: "d",
  format: "f",
  quality: "q"
};
var ACTION_TYPE_TO_EFFECT_MODE_MAP = {
  redEye: "redeye",
  advancedRedEye: "adv_redeye",
  oilPaint: "oil_paint",
  unsharpMask: "unsharp_mask",
  makeTransparent: "make_transparent",
  generativeRestore: "gen_restore",
  upscale: "upscale"
};
var ACTION_TYPE_TO_QUALITY_MODE_MAP = {
  autoBest: "auto:best",
  autoEco: "auto:eco",
  autoGood: "auto:good",
  autoLow: "auto:low",
  jpegminiHigh: "jpegmini:1",
  jpegminiMedium: "jpegmini:2",
  jpegminiBest: "jpegmini:0"
};
var ACTION_TYPE_TO_STREAMING_PROFILE_MODE_MAP = {
  fullHd: "full_hd",
  fullHdWifi: "full_hd_wifi",
  fullHdLean: "full_hd_lean",
  hdLean: "hd_lean"
};
var CHROMA_VALUE_TO_CHROMA_MODEL_ENUM = {
  444: "CHROMA_444",
  420: "CHROMA_420"
};
var COLOR_SPACE_MODEL_MODE_TO_COLOR_SPACE_MODE_MAP = {
  "noCmyk": "no_cmyk",
  "keepCmyk": "keep_cmyk",
  "tinySrgb": "tinysrgb",
  "srgbTrueColor": "srgb:truecolor"
};
var ACTION_TYPE_TO_BLEND_MODE_MAP = {
  "antiRemoval": "anti_removal"
};
var CHROMA_MODEL_ENUM_TO_CHROMA_VALUE = objectFlip(CHROMA_VALUE_TO_CHROMA_MODEL_ENUM);
var COLOR_SPACE_MODE_TO_COLOR_SPACE_MODEL_MODE_MAP = objectFlip(COLOR_SPACE_MODEL_MODE_TO_COLOR_SPACE_MODE_MAP);
var CROP_MODE_TO_ACTION_TYPE_MAP = objectFlip(ACTION_TYPE_TO_CROP_MODE_MAP);
var DELIVERY_MODE_TO_ACTION_TYPE_MAP = objectFlip(ACTION_TYPE_TO_DELIVERY_MODE_MAP);
var EFFECT_MODE_TO_ACTION_TYPE_MAP = objectFlip(ACTION_TYPE_TO_EFFECT_MODE_MAP);
var QUALITY_MODE_TO_ACTION_TYPE_MAP = objectFlip(ACTION_TYPE_TO_QUALITY_MODE_MAP);
var STREAMING_PROFILE_TO_ACTION_TYPE_MAP = objectFlip(ACTION_TYPE_TO_STREAMING_PROFILE_MODE_MAP);

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeSimpleAction.js
var ResizeSimpleAction = class extends Action {
  /**
   * @param {string} cropType
   * @param {number | string} cropWidth The required width of a transformed asset.
   * @param {number | string} cropHeight The required height of a transformed asset.
   */
  constructor(cropType, cropWidth, cropHeight) {
    super();
    this._actionModel = { dimensions: {} };
    this._actionModel.actionType = CROP_MODE_TO_ACTION_TYPE_MAP[cropType] || cropType;
    this.addQualifier(new Qualifier("c", cropType));
    cropWidth && this.width(cropWidth);
    cropHeight && this.height(cropHeight);
  }
  /**
   * @description Sets the height of the resize
   * @param {string | number} x The height in pixels (if an integer is specified) or as a percentage (if a float is specified).
   */
  height(x) {
    this._actionModel.dimensions.height = x;
    return this.addQualifier(new Qualifier("h", x));
  }
  /**
   * @description Sets the width of the resize
   * @param {string | number} x The width in pixels (if an integer is specified) or as a percentage (if a float is specified).
   */
  width(x) {
    this._actionModel.dimensions.width = x;
    return this.addQualifier(new Qualifier("w", x));
  }
  /**
   * @description Sets the aspect ratio of the asset.
   * For a list of supported types see {@link Qualifiers.AspectRatio|
    * AspectRatio values}
   * @param {AspectRatioType|number|string} ratio The new aspect ratio, specified as a percentage or ratio.
   * @return {this}
   */
  aspectRatio(ratio) {
    if (ratio instanceof AspectRatioQualifierValue) {
      this._actionModel.dimensions.aspectRatio = `${ratio}`;
      return this.addQualifier(new Qualifier("ar", ratio));
    }
    if (typeof ratio === "number" || typeof ratio === "string") {
      this._actionModel.dimensions.aspectRatio = toFloatAsString(ratio);
      return this.addQualifier(new Qualifier("ar", toFloatAsString(ratio)));
    }
    if (ratio instanceof FlagQualifier) {
      this._actionModel.dimensions.aspectRatio = `${ratio.qualifierValue}`;
      return this.addFlag(ratio);
    }
  }
  /**
   * @description Modifies percentage-based width & height parameters of overlays and underlays (e.g., 1.0) to be relative to the containing image instead of the added layer.
   * @return {this}
   */
  relative() {
    this._actionModel.relative = true;
    return this.addFlag(relative());
  }
  /**
   * @description Modifies percentage-based width & height parameters of overlays and underlays (e.g., 1.0) to be relative to the overlaid region
   * @return {this}
   */
  regionRelative() {
    this._actionModel.regionRelative = true;
    return this.addFlag(regionRelative());
  }
  static fromJson(actionModel) {
    const { actionType, dimensions, relative: relative2, regionRelative: regionRelative2 } = actionModel;
    const { aspectRatio, width, height } = dimensions;
    const cropMode = ACTION_TYPE_TO_CROP_MODE_MAP[actionType] || actionType;
    const result = new this(cropMode, width, height);
    aspectRatio && result.aspectRatio(aspectRatio === "ignore_aspect_ratio" ? ignoreInitialAspectRatio() : aspectRatio);
    relative2 && result.relative();
    regionRelative2 && result.regionRelative();
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gravity/GravityQualifier.js
var GravityQualifier = class extends Qualifier {
  /**
   * @param value, an array containing (GravityObject | AutoGravity | string) or a string;
   */
  constructor(value) {
    super("g", new QualifierValue(value));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gravity/autoGravity/AutoGravity.js
var AutoGravity = class extends GravityQualifier {
  constructor() {
    super("auto");
  }
  /**
   * @description Autofocuses on objects, allowing their priority within the algorithm to be configured.
   * @param {AutoFocus} AutoFocusObjects
   */
  autoFocus(...AutoFocusObjects) {
    this.addValue(AutoFocusObjects);
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gravity/focusOnGravity/FocusOnGravity.js
var FocusOnGravity = class extends GravityQualifier {
  constructor(FocusOnObjects) {
    super(FocusOnObjects);
  }
  /**
   * @description Specifies the gravity to use if none of the other gravity objects are found.
   * @param {Qualifiers.Gravity.AutoGravity} val
   */
  fallbackGravity(val) {
    this.addValue(val.qualifierValue);
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gravity/compassGravity/CompassGravity.js
var CompassGravity = class extends GravityQualifier {
  constructor(dir) {
    super(dir);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gravity/xyCenterGravity/XYCenterGravity.js
var XYCenterGravity = class extends GravityQualifier {
  constructor() {
    super("xy_center");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gravity.js
function compass(direction) {
  return new CompassGravity(direction);
}
function focusOn(...args) {
  const res = [...args];
  return new FocusOnGravity(res);
}
function autoGravity() {
  return new AutoGravity();
}
function xyCenter() {
  return new XYCenterGravity();
}
var Gravity = {
  compass,
  autoGravity,
  focusOn,
  xyCenter
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gravity/qualifiers/focusOn/FocusOnValue.js
var FocusOnValue = class extends QualifierValue {
  constructor(name2) {
    super();
    this.name = name2;
  }
  toString() {
    return this.name;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/focusOn.js
function ocr() {
  return new FocusOnValue("ocr_text");
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createGravityModel.js
function isIAutoGravityString(gravity) {
  return gravity && `${gravity}`.split(":")[0] === "auto";
}
function isCompassGravity(gravity) {
  const gravityValue = getGravityValue(gravity);
  return ["north", "center", "east", "west", "south", "north_west", "south_east", "south_west", "north_east"].includes(gravityValue);
}
function getGravityValue(gravity) {
  return `${gravity}`.replace("g_", "");
}
function createCompassGravityModel(gravity) {
  return {
    compass: getGravityValue(gravity),
    gravityType: "direction"
  };
}
function isOcrGravity(gravity) {
  return getGravityValue(gravity) === "ocr_text";
}
function createOcrGravityModel() {
  return {
    gravityType: "ocr"
  };
}
function isAutoGravity(gravity) {
  return `${gravity.qualifierValue}`.split(":")[0] === "auto";
}
function createIAutoFocusObject(gravity) {
  const gravityString = gravity.toString();
  const values = gravityString.split("_");
  const result = {
    object: values[0]
  };
  if (values.length > 1) {
    if (values[1] === "avoid") {
      result.avoid = true;
    } else {
      result.weight = +values[1];
    }
  }
  return result;
}
function createAutoGravityModel(gravity) {
  let values;
  const gravityQualifier = gravity === "auto" ? new AutoGravity() : gravity;
  if (`${gravity}`.startsWith("auto:")) {
    values = `${gravity}`.split(":").filter((v) => v !== "auto");
  } else {
    values = gravityQualifier.qualifierValue.values.filter((v) => v !== "auto");
  }
  const autoFocus = values.map(createIAutoFocusObject);
  return {
    gravityType: "auto",
    autoFocus
  };
}
function createFocusOnGravityModel(gravity) {
  const hasAutoGravity = `${gravity}`.split(":").includes("auto");
  const values = gravity.qualifierValue.values;
  const focusOnValues = hasAutoGravity ? values.slice(0, values.length - 1) : values;
  const result = {
    gravityType: "object",
    focusOnObjects: focusOnValues.map((v) => `${v}`)
  };
  if (hasAutoGravity) {
    const autoFocusObjects = values[values.length - 1].values.slice(1);
    const autoGravityInstance = autoGravity().autoFocus(...autoFocusObjects);
    result.fallbackGravity = createAutoGravityModel(autoGravityInstance);
  }
  return result;
}
function createFocusOnGravity(gravity) {
  const values = gravity.split(":");
  const focusOnValues = values.map((g) => new FocusOnValue(g));
  return new FocusOnGravity(focusOnValues);
}
function createGravityModel(gravity) {
  if (isCompassGravity(gravity)) {
    return createCompassGravityModel(gravity);
  }
  if (isOcrGravity(gravity)) {
    return createOcrGravityModel();
  }
  if (isIAutoGravityString(gravity) || isAutoGravity(gravity)) {
    return createAutoGravityModel(gravity);
  }
  return createFocusOnGravityModel(typeof gravity === "string" ? createFocusOnGravity(gravity) : gravity);
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/autoFocus.js
var AutoFocus = class _AutoFocus extends QualifierValue {
  constructor(focusOn3, weight) {
    super();
    this._weight = weight;
    this.focusOn = focusOn3;
    this.shouldAvoid = false;
  }
  /**
   * @summary qualifier
   * @description Specifies the object to focus on automatically
   * Accepts an AutoFocusObject (which is just a wrapper for a FocusOn object, but with extra method: avoid, weight)
   * @param {Qualifiers.FocusOn} obj The object to focus on.
   * @param {number} weight
   */
  static focusOn(obj, weight) {
    return new _AutoFocus(obj, weight);
  }
  shouldAddWeight() {
    return typeof this._weight === "number" || typeof this._weight === "string" || this.shouldAvoid;
  }
  /**
   * @summary qualifier
   * @desc Get the name of the of the object
   */
  getName() {
    return this.focusOn.name;
  }
  /**
   * @summary qualifier
   * @desc Get the weight for the object
   */
  getWeight() {
    if (this.shouldAvoid) {
      return "avoid";
    } else {
      return this._weight;
    }
  }
  /**
   * @summary qualifier
   * @desc Return the string representation of this QualifierValue
   */
  toString() {
    if (this.shouldAddWeight()) {
      return `${this.getName()}_${this.getWeight()}`;
    } else {
      return `${this.getName()}`;
    }
  }
  /**
   * @summary qualifier
   * @description Sets the importance level of the object within the automatic gravity algorithm
   * @param {numebr} w The focus weight for the object
   * @return {this}
   */
  weight(w) {
    this._weight = w;
    return this;
  }
  /**
   * @summary qualifier
   * @description Attempts to avoid the detected object in the image
   * @return {this}
   */
  avoid() {
    this.shouldAvoid = true;
    return this;
  }
};
var focusOn2 = AutoFocus.focusOn;

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gravity/qualifiers/compass/CompassQualifier.js
var CompassQualifier = class extends QualifierValue {
  constructor(val) {
    super();
    this.val = val;
  }
  toString() {
    return this.val;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createGravityFromModel.js
function isCompassGravityModel(gravityModel) {
  return gravityModel.gravityType === "direction";
}
function isOcrGravityModel(gravityModel) {
  return gravityModel.gravityType === "ocr";
}
function isAutoGravityModel(gravityModel) {
  return gravityModel.gravityType === "auto";
}
function createAutoFocusFromModel(autoGravityObjectModel) {
  const { object, weight, avoid } = autoGravityObjectModel;
  const autoFocus = new AutoFocus(new FocusOnValue(object));
  (weight || weight === 0) && autoFocus.weight(weight);
  avoid && autoFocus.avoid();
  return autoFocus;
}
function createAutoGravityFromModel(gravityModel) {
  const autoFocusModel = gravityModel.autoFocus || [];
  const autoFocus = autoFocusModel.map(createAutoFocusFromModel);
  return autoGravity().autoFocus(...autoFocus);
}
function createFocusOnGravityFromModel(gravityModel) {
  const focusOnObjects = (gravityModel.focusOnObjects || []).map((str) => new FocusOnValue(str));
  const result = focusOn(...focusOnObjects);
  if (gravityModel.fallbackGravity) {
    const autoGravity2 = createAutoGravityFromModel(gravityModel.fallbackGravity);
    result.fallbackGravity(autoGravity2);
  }
  return result;
}
function createGravityFromModel(gravityModel) {
  if (isCompassGravityModel(gravityModel)) {
    return new CompassGravity(new CompassQualifier(gravityModel.compass));
  }
  if (isOcrGravityModel(gravityModel)) {
    return focusOn(ocr());
  }
  if (isAutoGravityModel(gravityModel)) {
    return createAutoGravityFromModel(gravityModel);
  }
  return createFocusOnGravityFromModel(gravityModel);
}

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeAdvancedAction.js
var ResizeAdvancedAction = class extends ResizeSimpleAction {
  /**
   * @description Which part of the original image to include.
   * @param {Qualifiers.Gravity} gravity
   */
  gravity(gravity) {
    this._actionModel.gravity = createGravityModel(gravity);
    const gravityQualifier = typeof gravity === "string" ? new Qualifier("g", gravity) : gravity;
    return this.addQualifier(gravityQualifier);
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    if (actionModel.gravity) {
      result.gravity(createGravityFromModel(actionModel.gravity));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/base/BackgroundQualifier.js
var BackgroundQualifier = class extends Qualifier {
  constructor(backgroundValue) {
    super("b");
    if (backgroundValue) {
      this.addValue(backgroundValue);
    }
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/BlurredBackgroundAction.js
var BlurredBackgroundAction = class extends BackgroundQualifier {
  /**
   * @description Sets the intensity of the blur.
   * @param {number} value - The intensity of the blur.
   */
  intensity(value) {
    this.intensityLevel = value;
    return this;
  }
  /**
   * @description Sets the brightness of the background.
   * @param {number} value - The brightness of the background.
   */
  brightness(value) {
    this.brightnessLevel = value;
    return this;
  }
  /**
   * @description
   * Stringify the qualifier
   * BackgroundQualifiers don't have a value, but instead override the toString() function
   */
  toString() {
    return `
    b_blurred
    ${this.intensityLevel ? `:${this.intensityLevel}` : ""}
    ${this.brightnessLevel ? `:${this.brightnessLevel}` : ""}
    `.replace(/\s+/g, "");
  }
};
var BlurredBackgroundAction_default = BlurredBackgroundAction;

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/prepareColor.js
function prepareColor(color2) {
  if (color2) {
    return color2.match(/^#/) ? `rgb:${color2.substr(1)}` : color2;
  } else {
    return color2;
  }
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/base/BaseCommonBackground.js
var BaseCommonBackground = class extends BackgroundQualifier {
  constructor() {
    super();
    this._palette = [];
  }
  /**
   * @description Selects the strongest contrasting color to use for padding.
   * @return {this}
   */
  contrast() {
    this._contrast = true;
    return this;
  }
  /**
   * @description Defines the custom colors to use when resizing using content-aware padding.
   * @param {...string} colors One or more colors - Example: palette('green', 'red', blue')
   * @return {this}
   */
  palette(...colors) {
    this._palette = colors.map((color2) => {
      return prepareColor(color2);
    });
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/auto/BackgroundAutoBorderQualifier.js
var BackgroundAutoBorderQualifier = class extends BaseCommonBackground {
  /**
   * @description
   * Stringify the qualifier
   * BackgroundQualifiers don't have a value, but instead override the toString() function.
   */
  toString() {
    return `
    b_auto:border
    ${this._contrast ? "_contrast" : ""}
    ${this._palette.length ? `:palette_${this._palette.join("_")}` : ""}
    `.replace(/\s+/g, "");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/base/BaseGradientBackground.js
var BaseGradientBackground = class extends BaseCommonBackground {
  /**
   *
   * @description Sets the number of predominant colors to use (2 or 4).
   * @param {number} num
   * @return {this}
   */
  gradientColors(num) {
    this._gradientColors = num;
    return this;
  }
  /**
   * @description Sets the direction for a background gradient fade effect.
   * @param {Qualifiers.GradientDirection | GradientDirectionType | string} direction Use one of these functions
   * provided by {@link Qualifiers.GradientDirection|GradientDirection}
   * @return {this}
   */
  gradientDirection(direction) {
    this._gradientDirection = direction;
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/gradient/BackgroundBorderGradientQualifier.js
var BackgroundBorderGradientQualifier = class extends BaseGradientBackground {
  /**
   * @description
   * Stringify the qualifier
   * BackgroundQualifiers don't have a value, but instead override the toString() function.
   */
  toString() {
    return `
    b_auto:border_gradient
    ${this._contrast ? "_contrast" : ""}
    ${this._gradientColors ? `:${this._gradientColors}` : ""}
    ${this._gradientDirection ? `:${this._gradientDirection}` : ""}
    ${this._palette.length ? `:palette_${this._palette.join("_")}` : ""}
    `.replace(/\s+/g, "");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/gradient/BackgroundPredominantGradientQualifier.js
var BackgroundPredominantGradientQualifier = class extends BaseGradientBackground {
  /**
   * @description
   * Stringify the qualifier
   * BackgroundQualifiers don't have a value, but instead override the toString() function.
   */
  toString() {
    return `
    b_auto:predominant_gradient
    ${this._contrast ? "_contrast" : ""}
    ${this._gradientColors ? `:${this._gradientColors}` : ""}
    ${this._gradientDirection ? `:${this._gradientDirection}` : ""}
    ${this._palette.length ? `:palette_${this._palette.join("_")}` : ""}
    `.replace(/\s+/g, "");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/auto/BackgroundAutoPredominantQualifier.js
var BackgroundAutoPredominantQualifier = class extends BaseCommonBackground {
  /**
   * @description
   * Stringify the qualifier
   * BackgroundQualifiers don't have a value, but instead override the toString() function.
   */
  toString() {
    return `
    b_auto:predominant
    ${this._contrast ? "_contrast" : ""}
    ${this._palette.length ? `:palette_${this._palette.join("_")}` : ""}
    `.replace(/\s+/g, "");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background/shared/BackgroundGenerativeFillQualifier.js
var BackgroundGenerativeFillQualifier = class extends BackgroundQualifier {
  constructor() {
    super("gen_fill");
    this._backgroundType = "generativeFill";
  }
  prompt(prompt) {
    this._prompt = prompt;
    return this;
  }
  getPrompt() {
    return this._prompt;
  }
  getBackgroundType() {
    return this._backgroundType;
  }
  /**
   * @description
   * Override the toString() function to explicitly stringify the qualifier.
   */
  toString() {
    return `b_gen_fill${this._prompt ? `:prompt_${this._prompt}` : ""}`;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createBackgroundModel.js
function getBackgroundValue(background) {
  return `${background}`.replace("b_", "");
}
function createAutoBackgroundModel() {
  return { backgroundType: "auto" };
}
function createBlurredBackgroundModel(background) {
  const { intensityLevel, brightnessLevel } = background;
  const result = {
    backgroundType: "blurred"
  };
  if (intensityLevel || intensityLevel === 0) {
    result.intensity = intensityLevel;
  }
  if (brightnessLevel || brightnessLevel === 0) {
    result.brightness = brightnessLevel;
  }
  return result;
}
function createContrastPaletteBackgroundModel(background) {
  const contrast2 = background._contrast;
  const palette = background._palette;
  const result = {
    backgroundType: ""
  };
  if (contrast2) {
    result.contrast = true;
  }
  if (palette) {
    result.palette = palette;
  }
  return result;
}
function createBorderBackgroundModel(background) {
  return Object.assign(Object.assign({}, createContrastPaletteBackgroundModel(background)), { backgroundType: "border" });
}
function createBaseGradientBackgroundModel(background) {
  const gradientColors = background._gradientColors;
  const gradientDirection = `${background._gradientDirection}`;
  const result = createContrastPaletteBackgroundModel(background);
  if (gradientColors) {
    result.gradientColors = gradientColors;
  }
  if (gradientDirection) {
    result.gradientDirection = gradientDirection;
  }
  return result;
}
function createBorderGradientBackgroundModel(background) {
  return Object.assign(Object.assign({}, createBaseGradientBackgroundModel(background)), { backgroundType: "borderGradient" });
}
function createColorBackgroundModel(background) {
  return {
    backgroundType: "color",
    color: getBackgroundValue(background)
  };
}
function createPredominantBackgroundModel(background) {
  return Object.assign(Object.assign({}, createContrastPaletteBackgroundModel(background)), { backgroundType: "predominant" });
}
function createPredominantGradientBackgroundModel(background) {
  return Object.assign(Object.assign({}, createBaseGradientBackgroundModel(background)), { backgroundType: "predominantGradient" });
}
function createGenerativeFillBackgroundModel(background) {
  return Object.assign({ backgroundType: background.getBackgroundType() }, background.getPrompt() ? { prompt: background.getPrompt() } : {});
}
function createBackgroundModel(background) {
  if (getBackgroundValue(background) === "auto") {
    return createAutoBackgroundModel();
  }
  if (background instanceof BlurredBackgroundAction_default) {
    return createBlurredBackgroundModel(background);
  }
  if (background instanceof BackgroundAutoBorderQualifier) {
    return createBorderBackgroundModel(background);
  }
  if (background instanceof BackgroundBorderGradientQualifier) {
    return createBorderGradientBackgroundModel(background);
  }
  if (background instanceof BackgroundAutoPredominantQualifier) {
    return createPredominantBackgroundModel(background);
  }
  if (background instanceof BackgroundPredominantGradientQualifier) {
    return createPredominantGradientBackgroundModel(background);
  }
  if (background instanceof BackgroundGenerativeFillQualifier) {
    return createGenerativeFillBackgroundModel(background);
  }
  return createColorBackgroundModel(background);
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/textDecoration.js
function normal() {
  return "";
}
function underline() {
  return "underline";
}
function strikethrough() {
  return "strikethrough";
}
var TextDecoration = { normal, underline, strikethrough };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/textAlignment.js
function left() {
  return "left";
}
function right() {
  return "right";
}
function center() {
  return "center";
}
function start() {
  return "start";
}
function end() {
  return "end";
}
function justify() {
  return "justify";
}
var TextAlignment = { left, right, center, end, justify, start };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/textStroke.js
function solid(width, color2) {
  return `bo_${width}px_solid_${color2}`;
}
var Stroke = { solid };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/streamingProfile.js
function fullHd() {
  return "full_hd";
}
function hd() {
  return "hd";
}
function sd() {
  return "sd";
}
function fullHdWifi() {
  return "full_hd_wifi";
}
function fullHdLean() {
  return "full_hd_lean";
}
function hdLean() {
  return "hd_lean";
}
var StreamingProfile = {
  hd,
  sd,
  hdLean,
  fullHd,
  fullHdLean,
  fullHdWifi
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/simulateColorBlind.js
function deuteranopia() {
  return "deuteranopia";
}
function protanopia() {
  return "protanopia";
}
function tritanopia() {
  return "tritanopia";
}
function tritanomaly() {
  return "tritanomaly";
}
function deuteranomaly() {
  return "deuteranomaly";
}
function coneMonochromacy() {
  return "cone_monochromacy";
}
function rodMonochromacy() {
  return "rod_monochromacy";
}
var SimulateColorBlind = {
  coneMonochromacy,
  deuteranomaly,
  deuteranopia,
  protanopia,
  rodMonochromacy,
  tritanomaly,
  tritanopia
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/rotate/RotationModeQualifierValue.js
var RotationModeQualifierValue = class extends QualifierValue {
  constructor(val) {
    super();
    this.val = val;
  }
  toString() {
    return this.val;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/rotationMode.js
function autoRight() {
  return new RotationModeQualifierValue("auto_right");
}
function autoLeft() {
  return new RotationModeQualifierValue("auto_left");
}
function verticalFlip() {
  return new RotationModeQualifierValue("vflip");
}
function horizontalFlip() {
  return new RotationModeQualifierValue("hflip");
}
function ignore() {
  return new RotationModeQualifierValue("ignore");
}
var RotationMode = { autoLeft, autoRight, horizontalFlip, ignore, verticalFlip };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/region/NamedRegion.js
var NamedRegion = class extends Action {
  constructor(type) {
    super();
    this.regionType = type;
    this._actionModel.regionType = type;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/region/CustomRegion.js
var CustomRegion = class _CustomRegion extends NamedRegion {
  constructor() {
    super("custom");
  }
  /**
   * @description The x position in pixels.
   * @param {number | string} x
   */
  x(x) {
    this._actionModel.x = x;
    this.addQualifier(new Qualifier("x", x));
    return this;
  }
  /**
   * @description The y position in pixels.
   * @param {number | string} y
   */
  y(y) {
    this._actionModel.y = y;
    this.addQualifier(new Qualifier("y", y));
    return this;
  }
  /**
   * @description The width of the region in pixels.
   * @param {number | string} width
   */
  width(width) {
    this._actionModel.width = width;
    this.addQualifier(new Qualifier("w", width));
    return this;
  }
  /**
   * @description The height of the region in pixels.
   * @param {number | string} height
   */
  height(height) {
    this._actionModel.height = height;
    this.addQualifier(new Qualifier("h", height));
    return this;
  }
  static fromJson(model) {
    const customRegion = new _CustomRegion();
    if (model.width) {
      customRegion.width(model.width);
    }
    if (model.height) {
      customRegion.height(model.height);
    }
    if (model.x) {
      customRegion.x(model.x);
    }
    if (model.y) {
      customRegion.y(model.y);
    }
    return customRegion;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/region/RectangleRegion.js
var RectangleRegion = class extends Action {
  /**
   * Rectangle defines a region where action will be applied
   *
   * @param {number} x The x position in pixels
   * @param {number} y The y position in pixels
   * @param {number} width The width in pixels
   * @param {number} height The height in pixels
   */
  constructor(x, y, width, height) {
    super();
    this.addQualifier(new Qualifier("x", x));
    this.addQualifier(new Qualifier("y", y));
    this.addQualifier(new Qualifier("w", width));
    this.addQualifier(new Qualifier("h", height));
    this._actionModel = {
      x,
      y,
      width,
      height
    };
  }
  toString() {
    const { x, y, width, height } = this._actionModel;
    return `(x_${x};y_${y};w_${width};h_${height})`;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/region.js
function custom() {
  return new CustomRegion();
}
function faces() {
  return new NamedRegion("faces");
}
function ocr2() {
  return new NamedRegion("ocr_text");
}
function rectangle(x, y, width, height) {
  return new RectangleRegion(x, y, width, height);
}
var Region = { ocr: ocr2, faces, custom, rectangle };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/quality.js
function auto() {
  return "auto";
}
function autoBest() {
  return "auto:best";
}
function autoEco() {
  return "auto:eco";
}
function autoGood() {
  return "auto:good";
}
function autoLow() {
  return "auto:low";
}
function jpegmini() {
  return "jpegmini";
}
function jpegminiBest() {
  return "jpegmini:0";
}
function jpegminiHigh() {
  return "jpegmini:1";
}
function jpegminiMedium() {
  return "jpegmini:2";
}
var Quality = { auto, autoBest, autoEco, autoGood, autoLow, jpegmini, jpegminiBest, jpegminiHigh, jpegminiMedium };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/position/PositionQualifier.js
var PositionQualifier = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
  }
  gravity(gravityQualifier) {
    this.addQualifier(gravityQualifier);
    this._actionModel.gravity = createGravityModel(gravityQualifier);
    return this;
  }
  /**
   * @description Tiles the overlay across your image.
   * <b>Learn more:</b> {@link https://cloudinary.com/documentation/layers#automatic_tiling|Tiling overlay}
   */
  tiled() {
    this.addFlag(tiled());
    this._actionModel.tiled = true;
    return this;
  }
  /**
   * TODO - This should accept a boolean value
   * @description Prevents an image or text overlay from extending a delivered image canvas beyond the dimensions of the base image
   * <b>Learn more:</b> {@link https://cloudinary.com/documentation/transformation_reference#fl_no_overflow|Overflow in overlays}
   */
  allowOverflow(bool = true) {
    if (bool === false) {
      this.addFlag(noOverflow());
    }
    this._actionModel.allowOverflow = bool;
    return this;
  }
  /**
   * @description Set the X Offset
   * @param {number | string} offsetX
   * @return {this}
   */
  offsetX(offsetX) {
    this.addQualifier(new Qualifier("x", offsetX));
    this._actionModel.offsetX = offsetX;
    return this;
  }
  /**
   * @description Set the Y Offset
   * @param {number | string} offsetY
   * @return {this}
   */
  offsetY(offsetY) {
    this.addQualifier(new Qualifier("y", offsetY));
    this._actionModel.offsetY = offsetY;
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/outlineMode.js
function fill() {
  return "fill";
}
function inner() {
  return "inner";
}
function innerFill() {
  return "inner_fill";
}
function outer() {
  return "outer";
}
var OutlineMode = {
  outer,
  inner,
  innerFill,
  fill
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/improveMode.js
function outdoor() {
  return "outdoor";
}
function indoor() {
  return "indoor";
}
var ImproveMode = {
  indoor,
  outdoor
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gradientDirection/GradientDirectionQualifierValue.js
var GradientDirectionQualifierValue = class extends QualifierValue {
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/gradientDirection.js
function horizontal() {
  return new GradientDirectionQualifierValue("horizontal");
}
function vertical() {
  return new GradientDirectionQualifierValue("vertical");
}
function diagonalDesc() {
  return new GradientDirectionQualifierValue("diagonal_desc");
}
function diagonalAsc() {
  return new GradientDirectionQualifierValue("diagonal_asc");
}
var GradientDirection = {
  horizontal,
  vertical,
  diagonalDesc,
  diagonalAsc
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/format/FormatQualifier.js
var FormatQualifier = class extends QualifierValue {
  constructor(val) {
    super(val);
    this.val = val;
  }
  getValue() {
    return this.val;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/format.js
function heic() {
  return new FormatQualifier("heic");
}
function flif() {
  return new FormatQualifier("flif");
}
function ai() {
  return new FormatQualifier("ai");
}
function wdp() {
  return new FormatQualifier("wdp");
}
function svg() {
  return new FormatQualifier("svg");
}
function webp() {
  return new FormatQualifier("webp");
}
function psd() {
  return new FormatQualifier("psd");
}
function jp2() {
  return new FormatQualifier("jp2");
}
function jpc() {
  return new FormatQualifier("jpc");
}
function eps() {
  return new FormatQualifier("eps");
}
function tiff() {
  return new FormatQualifier("tiff");
}
function pdf() {
  return new FormatQualifier("pdf");
}
function ico() {
  return new FormatQualifier("ico");
}
function bmp() {
  return new FormatQualifier("bmp");
}
function png() {
  return new FormatQualifier("png");
}
function gif() {
  return new FormatQualifier("gif");
}
function auto2() {
  return new FormatQualifier("auto");
}
function jpg() {
  return new FormatQualifier("jpg");
}
function djvu() {
  return new FormatQualifier("djvu");
}
function ps() {
  return new FormatQualifier("ps");
}
function ept() {
  return new FormatQualifier("ept");
}
function eps3() {
  return new FormatQualifier("eps3");
}
function fxb() {
  return new FormatQualifier("fxb");
}
function gltf() {
  return new FormatQualifier("gltf");
}
function heif() {
  return new FormatQualifier("heif");
}
function indd() {
  return new FormatQualifier("indd");
}
function jpe() {
  return new FormatQualifier("jpe");
}
function jpeg() {
  return new FormatQualifier("jpeg");
}
function jxr() {
  return new FormatQualifier("jxr");
}
function hdp() {
  return new FormatQualifier("hdp");
}
function spd() {
  return new FormatQualifier("spd");
}
function arw() {
  return new FormatQualifier("arw");
}
function cr2() {
  return new FormatQualifier("cr2");
}
function tga() {
  return new FormatQualifier("tga");
}
function tif() {
  return new FormatQualifier("tif");
}
function avif() {
  return new FormatQualifier("avif");
}
function usdz() {
  return new FormatQualifier("usdz");
}
function video3g2() {
  return new FormatQualifier("3g2");
}
function video3gp() {
  return new FormatQualifier("3gp");
}
function videoAvi() {
  return new FormatQualifier("avi");
}
function videoFlv() {
  return new FormatQualifier("flv");
}
function videoM3u8() {
  return new FormatQualifier("m3u8");
}
function videoTs() {
  return new FormatQualifier("ts");
}
function videoMov() {
  return new FormatQualifier("mov");
}
function videoMkv() {
  return new FormatQualifier("mkv");
}
function videoMp4() {
  return new FormatQualifier("mp4");
}
function videoMpeg() {
  return new FormatQualifier("mpeg");
}
function videoMpd() {
  return new FormatQualifier("mpd");
}
function videoMxf() {
  return new FormatQualifier("mxf");
}
function videoOgv() {
  return new FormatQualifier("ogv");
}
function videoWebm() {
  return new FormatQualifier("webm");
}
function videoWmv() {
  return new FormatQualifier("wmv");
}
function videoM2ts() {
  return new FormatQualifier("m2ts");
}
function videoMts() {
  return new FormatQualifier("mts");
}
function audioAac() {
  return new FormatQualifier("aac");
}
function audioAiff() {
  return new FormatQualifier("aiff");
}
function audioAmr() {
  return new FormatQualifier("amr");
}
function audioFlac() {
  return new FormatQualifier("flac");
}
function audioM4a() {
  return new FormatQualifier("m4a");
}
function audioMp3() {
  return new FormatQualifier("mp3");
}
function audioOgg() {
  return new FormatQualifier("ogg");
}
function audioOpus() {
  return new FormatQualifier("opus");
}
function audioWav() {
  return new FormatQualifier("wav");
}
function glb() {
  return new FormatQualifier("glb");
}
var Format = { usdz, jp2, ai, auto: auto2, bmp, eps, flif, gif, heic, ico, jpc, jpg, pdf, png, psd, svg, tiff, wdp, webp, arw, audioAac, audioAiff, audioAmr, audioFlac, audioM4a, audioMp3, audioOgg, audioOpus, audioWav, avif, cr2, djvu, eps3, ept, fxb, gltf, hdp, heif, indd, jpe, jpeg, jxr, ps, spd, tga, tif, video3g2, video3gp, videoAvi, videoFlv, videoM2ts, videoM3u8, videoMkv, videoMov, videoMp4, videoMpd, videoMpeg, videoMts, videoMxf, videoOgv, videoTs, videoWebm, videoWmv, glb };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/fontWeight.js
function thin() {
  return "thin";
}
function light() {
  return "light";
}
function normal2() {
  return "normal";
}
function bold() {
  return "bold";
}
var FontWeight = { bold, light, normal: normal2, thin };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/fontStyle.js
function normal3() {
  return "normal";
}
function italic() {
  return "italic";
}
var FontStyle = { normal: normal3, italic };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/fontHinting.js
function none() {
  return "";
}
function slight() {
  return "slight";
}
function medium() {
  return "medium";
}
function full() {
  return "full";
}
var FontHinting = { full, none, medium, slight };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/expression/ExpressionQualifier.js
var ExpressionQualifier = class extends QualifierValue {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return this.value;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/expression.js
function expression(exp) {
  const reservedOperatorList = Object.keys(CONDITIONAL_OPERATORS).map((key) => {
    return `\\s${key.replace(/(\*|\+|\^|\|)/g, "\\$1")}\\s`;
  });
  const regexSafeOperatorList = reservedOperatorList.join("|");
  const operatorsReplaceRE = new RegExp(`(${regexSafeOperatorList})`, "g");
  const stringWithOperators = exp.toString().replace(operatorsReplaceRE, (match) => {
    return `_${CONDITIONAL_OPERATORS[match.trim()]}_`;
  });
  const ReservedNames = Object.keys(RESERVED_NAMES);
  const regexSafeReservedNameList = ReservedNames.join("|");
  const reservedNamesRE = new RegExp(`(\\$_*[^_ ]+)|${regexSafeReservedNameList}`, "g");
  const stringWithVariables = stringWithOperators.replace(reservedNamesRE, (match) => {
    if (match.startsWith("$")) {
      return match;
    } else {
      return RESERVED_NAMES[match] || match;
    }
  });
  const finalExpressionString = stringWithVariables.replace(/\s/g, "_");
  return new ExpressionQualifier(finalExpressionString);
}
var Expression = {
  expression
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/dither.js
function threshold1x1Nondither() {
  return 0;
}
function checkerboard2x1Dither() {
  return 1;
}
function ordered2x2Dispersed() {
  return 2;
}
function ordered3x3Dispersed() {
  return 3;
}
function ordered4x4Dispersed() {
  return 4;
}
function ordered8x8Dispersed() {
  return 5;
}
function halftone4x4Angled() {
  return 6;
}
function halftone6x6Angled() {
  return 7;
}
function halftone8x8Angled() {
  return 8;
}
function halftone4x4Orthogonal() {
  return 9;
}
function halftone6x6Orthogonal() {
  return 10;
}
function halftone8x8Orthogonal() {
  return 11;
}
function halftone16x16Orthogonal() {
  return 12;
}
function circles5x5Black() {
  return 13;
}
function circles5x5White() {
  return 14;
}
function circles6x6Black() {
  return 15;
}
function circles6x6White() {
  return 16;
}
function circles7x7Black() {
  return 17;
}
function circles7x7White() {
  return 18;
}
var Dither = {
  checkerboard2x1Dither,
  circles5x5Black,
  circles5x5White,
  circles6x6Black,
  circles6x6White,
  circles7x7Black,
  circles7x7White,
  halftone4x4Angled,
  halftone4x4Orthogonal,
  halftone6x6Angled,
  halftone6x6Orthogonal,
  halftone8x8Angled,
  halftone8x8Orthogonal,
  halftone16x16Orthogonal,
  ordered2x2Dispersed,
  ordered3x3Dispersed,
  ordered4x4Dispersed,
  ordered8x8Dispersed,
  threshold1x1Nondither
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/colorSpace.js
function srgb() {
  return "srgb";
}
function trueColor() {
  return "srgb:truecolor";
}
function tinySrgb() {
  return "tinysrgb";
}
function cmyk() {
  return "cmyk";
}
function noCmyk() {
  return "no_cmyk";
}
function keepCmyk() {
  return "keep_cmyk";
}
var ColorSpace = {
  cmyk,
  keepCmyk,
  noCmyk,
  srgb,
  tinySrgb,
  trueColor
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/color.js
var Color = {
  SNOW: "snow",
  SNOW1: "snow1",
  SNOW2: "snow2",
  ROSYBROWN1: "rosybrown1",
  ROSYBROWN2: "rosybrown2",
  SNOW3: "snow3",
  LIGHTCORAL: "lightcoral",
  INDIANRED1: "indianred1",
  ROSYBROWN3: "rosybrown3",
  INDIANRED2: "indianred2",
  ROSYBROWN: "rosybrown",
  BROWN1: "brown1",
  FIREBRICK1: "firebrick1",
  BROWN2: "brown2",
  INDIANRED: "indianred",
  INDIANRED3: "indianred3",
  FIREBRICK2: "firebrick2",
  SNOW4: "snow4",
  BROWN3: "brown3",
  RED: "red",
  RED1: "red1",
  ROSYBROWN4: "rosybrown4",
  FIREBRICK3: "firebrick3",
  RED2: "red2",
  FIREBRICK: "firebrick",
  BROWN: "brown",
  RED3: "red3",
  INDIANRED4: "indianred4",
  BROWN4: "brown4",
  FIREBRICK4: "firebrick4",
  DARKRED: "darkred",
  RED4: "red4",
  LIGHTPINK1: "lightpink1",
  LIGHTPINK3: "lightpink3",
  LIGHTPINK4: "lightpink4",
  LIGHTPINK2: "lightpink2",
  LIGHTPINK: "lightpink",
  PINK: "pink",
  CRIMSON: "crimson",
  PINK1: "pink1",
  PINK2: "pink2",
  PINK3: "pink3",
  PINK4: "pink4",
  PALEVIOLETRED4: "palevioletred4",
  PALEVIOLETRED: "palevioletred",
  PALEVIOLETRED2: "palevioletred2",
  PALEVIOLETRED1: "palevioletred1",
  PALEVIOLETRED3: "palevioletred3",
  LAVENDERBLUSH: "lavenderblush",
  LAVENDERBLUSH1: "lavenderblush1",
  LAVENDERBLUSH3: "lavenderblush3",
  LAVENDERBLUSH2: "lavenderblush2",
  LAVENDERBLUSH4: "lavenderblush4",
  MAROON: "maroon",
  HOTPINK3: "hotpink3",
  VIOLETRED3: "violetred3",
  VIOLETRED1: "violetred1",
  VIOLETRED2: "violetred2",
  VIOLETRED4: "violetred4",
  HOTPINK2: "hotpink2",
  HOTPINK1: "hotpink1",
  HOTPINK4: "hotpink4",
  HOTPINK: "hotpink",
  DEEPPINK: "deeppink",
  DEEPPINK1: "deeppink1",
  DEEPPINK2: "deeppink2",
  DEEPPINK3: "deeppink3",
  DEEPPINK4: "deeppink4",
  MAROON1: "maroon1",
  MAROON2: "maroon2",
  MAROON3: "maroon3",
  MAROON4: "maroon4",
  MEDIUMVIOLETRED: "mediumvioletred",
  VIOLETRED: "violetred",
  ORCHID2: "orchid2",
  ORCHID: "orchid",
  ORCHID1: "orchid1",
  ORCHID3: "orchid3",
  ORCHID4: "orchid4",
  THISTLE1: "thistle1",
  THISTLE2: "thistle2",
  PLUM1: "plum1",
  PLUM2: "plum2",
  THISTLE: "thistle",
  THISTLE3: "thistle3",
  PLUM: "plum",
  VIOLET: "violet",
  PLUM3: "plum3",
  THISTLE4: "thistle4",
  FUCHSIA: "fuchsia",
  MAGENTA: "magenta",
  MAGENTA1: "magenta1",
  PLUM4: "plum4",
  MAGENTA2: "magenta2",
  MAGENTA3: "magenta3",
  DARKMAGENTA: "darkmagenta",
  MAGENTA4: "magenta4",
  PURPLE: "purple",
  MEDIUMORCHID: "mediumorchid",
  MEDIUMORCHID1: "mediumorchid1",
  MEDIUMORCHID2: "mediumorchid2",
  MEDIUMORCHID3: "mediumorchid3",
  MEDIUMORCHID4: "mediumorchid4",
  DARKVIOLET: "darkviolet",
  DARKORCHID: "darkorchid",
  DARKORCHID1: "darkorchid1",
  DARKORCHID3: "darkorchid3",
  DARKORCHID2: "darkorchid2",
  DARKORCHID4: "darkorchid4",
  INDIGO: "indigo",
  BLUEVIOLET: "blueviolet",
  PURPLE2: "purple2",
  PURPLE3: "purple3",
  PURPLE4: "purple4",
  PURPLE1: "purple1",
  MEDIUMPURPLE: "mediumpurple",
  MEDIUMPURPLE1: "mediumpurple1",
  MEDIUMPURPLE2: "mediumpurple2",
  MEDIUMPURPLE3: "mediumpurple3",
  MEDIUMPURPLE4: "mediumpurple4",
  DARKSLATEBLUE: "darkslateblue",
  LIGHTSLATEBLUE: "lightslateblue",
  MEDIUMSLATEBLUE: "mediumslateblue",
  SLATEBLUE: "slateblue",
  SLATEBLUE1: "slateblue1",
  SLATEBLUE2: "slateblue2",
  SLATEBLUE3: "slateblue3",
  SLATEBLUE4: "slateblue4",
  GHOSTWHITE: "ghostwhite",
  LAVENDER: "lavender",
  BLUE: "blue",
  BLUE1: "blue1",
  BLUE2: "blue2",
  BLUE3: "blue3",
  MEDIUMBLUE: "mediumblue",
  BLUE4: "blue4",
  DARKBLUE: "darkblue",
  MIDNIGHTBLUE: "midnightblue",
  NAVY: "navy",
  NAVYBLUE: "navyblue",
  ROYALBLUE: "royalblue",
  ROYALBLUE1: "royalblue1",
  ROYALBLUE2: "royalblue2",
  ROYALBLUE3: "royalblue3",
  ROYALBLUE4: "royalblue4",
  CORNFLOWERBLUE: "cornflowerblue",
  LIGHTSTEELBLUE: "lightsteelblue",
  LIGHTSTEELBLUE1: "lightsteelblue1",
  LIGHTSTEELBLUE2: "lightsteelblue2",
  LIGHTSTEELBLUE3: "lightsteelblue3",
  LIGHTSTEELBLUE4: "lightsteelblue4",
  SLATEGRAY4: "slategray4",
  SLATEGRAY1: "slategray1",
  SLATEGRAY2: "slategray2",
  SLATEGRAY3: "slategray3",
  LIGHTSLATEGRAY: "lightslategray",
  LIGHTSLATEGREY: "lightslategrey",
  SLATEGRAY: "slategray",
  SLATEGREY: "slategrey",
  DODGERBLUE: "dodgerblue",
  DODGERBLUE1: "dodgerblue1",
  DODGERBLUE2: "dodgerblue2",
  DODGERBLUE4: "dodgerblue4",
  DODGERBLUE3: "dodgerblue3",
  ALICEBLUE: "aliceblue",
  STEELBLUE4: "steelblue4",
  STEELBLUE: "steelblue",
  STEELBLUE1: "steelblue1",
  STEELBLUE2: "steelblue2",
  STEELBLUE3: "steelblue3",
  SKYBLUE4: "skyblue4",
  SKYBLUE1: "skyblue1",
  SKYBLUE2: "skyblue2",
  SKYBLUE3: "skyblue3",
  LIGHTSKYBLUE: "lightskyblue",
  LIGHTSKYBLUE4: "lightskyblue4",
  LIGHTSKYBLUE1: "lightskyblue1",
  LIGHTSKYBLUE2: "lightskyblue2",
  LIGHTSKYBLUE3: "lightskyblue3",
  SKYBLUE: "skyblue",
  LIGHTBLUE3: "lightblue3",
  DEEPSKYBLUE: "deepskyblue",
  DEEPSKYBLUE1: "deepskyblue1",
  DEEPSKYBLUE2: "deepskyblue2",
  DEEPSKYBLUE4: "deepskyblue4",
  DEEPSKYBLUE3: "deepskyblue3",
  LIGHTBLUE1: "lightblue1",
  LIGHTBLUE2: "lightblue2",
  LIGHTBLUE: "lightblue",
  LIGHTBLUE4: "lightblue4",
  POWDERBLUE: "powderblue",
  CADETBLUE1: "cadetblue1",
  CADETBLUE2: "cadetblue2",
  CADETBLUE3: "cadetblue3",
  CADETBLUE4: "cadetblue4",
  TURQUOISE1: "turquoise1",
  TURQUOISE2: "turquoise2",
  TURQUOISE3: "turquoise3",
  TURQUOISE4: "turquoise4",
  CADETBLUE: "cadetblue",
  DARKTURQUOISE: "darkturquoise",
  AZURE: "azure",
  AZURE1: "azure1",
  LIGHTCYAN1: "lightcyan1",
  LIGHTCYAN: "lightcyan",
  AZURE2: "azure2",
  LIGHTCYAN2: "lightcyan2",
  PALETURQUOISE1: "paleturquoise1",
  PALETURQUOISE: "paleturquoise",
  PALETURQUOISE2: "paleturquoise2",
  DARKSLATEGRAY1: "darkslategray1",
  AZURE3: "azure3",
  LIGHTCYAN3: "lightcyan3",
  DARKSLATEGRAY2: "darkslategray2",
  PALETURQUOISE3: "paleturquoise3",
  DARKSLATEGRAY3: "darkslategray3",
  AZURE4: "azure4",
  LIGHTCYAN4: "lightcyan4",
  AQUA: "aqua",
  CYAN: "cyan",
  CYAN1: "cyan1",
  PALETURQUOISE4: "paleturquoise4",
  CYAN2: "cyan2",
  DARKSLATEGRAY4: "darkslategray4",
  CYAN3: "cyan3",
  CYAN4: "cyan4",
  DARKCYAN: "darkcyan",
  TEAL: "teal",
  DARKSLATEGRAY: "darkslategray",
  DARKSLATEGREY: "darkslategrey",
  MEDIUMTURQUOISE: "mediumturquoise",
  LIGHTSEAGREEN: "lightseagreen",
  TURQUOISE: "turquoise",
  AQUAMARINE4: "aquamarine4",
  AQUAMARINE: "aquamarine",
  AQUAMARINE1: "aquamarine1",
  AQUAMARINE2: "aquamarine2",
  AQUAMARINE3: "aquamarine3",
  MEDIUMAQUAMARINE: "mediumaquamarine",
  MEDIUMSPRINGGREEN: "mediumspringgreen",
  MINTCREAM: "mintcream",
  SPRINGGREEN: "springgreen",
  SPRINGGREEN1: "springgreen1",
  SPRINGGREEN2: "springgreen2",
  SPRINGGREEN3: "springgreen3",
  SPRINGGREEN4: "springgreen4",
  MEDIUMSEAGREEN: "mediumseagreen",
  SEAGREEN: "seagreen",
  SEAGREEN3: "seagreen3",
  SEAGREEN1: "seagreen1",
  SEAGREEN4: "seagreen4",
  SEAGREEN2: "seagreen2",
  MEDIUMFORESTGREEN: "mediumforestgreen",
  HONEYDEW: "honeydew",
  HONEYDEW1: "honeydew1",
  HONEYDEW2: "honeydew2",
  DARKSEAGREEN1: "darkseagreen1",
  DARKSEAGREEN2: "darkseagreen2",
  PALEGREEN1: "palegreen1",
  PALEGREEN: "palegreen",
  HONEYDEW3: "honeydew3",
  LIGHTGREEN: "lightgreen",
  PALEGREEN2: "palegreen2",
  DARKSEAGREEN3: "darkseagreen3",
  DARKSEAGREEN: "darkseagreen",
  PALEGREEN3: "palegreen3",
  HONEYDEW4: "honeydew4",
  GREEN1: "green1",
  LIME: "lime",
  LIMEGREEN: "limegreen",
  DARKSEAGREEN4: "darkseagreen4",
  GREEN2: "green2",
  PALEGREEN4: "palegreen4",
  GREEN3: "green3",
  FORESTGREEN: "forestgreen",
  GREEN4: "green4",
  GREEN: "green",
  DARKGREEN: "darkgreen",
  LAWNGREEN: "lawngreen",
  CHARTREUSE: "chartreuse",
  CHARTREUSE1: "chartreuse1",
  CHARTREUSE2: "chartreuse2",
  CHARTREUSE3: "chartreuse3",
  CHARTREUSE4: "chartreuse4",
  GREENYELLOW: "greenyellow",
  DARKOLIVEGREEN3: "darkolivegreen3",
  DARKOLIVEGREEN1: "darkolivegreen1",
  DARKOLIVEGREEN2: "darkolivegreen2",
  DARKOLIVEGREEN4: "darkolivegreen4",
  DARKOLIVEGREEN: "darkolivegreen",
  OLIVEDRAB: "olivedrab",
  OLIVEDRAB1: "olivedrab1",
  OLIVEDRAB2: "olivedrab2",
  OLIVEDRAB3: "olivedrab3",
  YELLOWGREEN: "yellowgreen",
  OLIVEDRAB4: "olivedrab4",
  IVORY: "ivory",
  IVORY1: "ivory1",
  LIGHTYELLOW: "lightyellow",
  LIGHTYELLOW1: "lightyellow1",
  BEIGE: "beige",
  IVORY2: "ivory2",
  LIGHTGOLDENRODYELLOW: "lightgoldenrodyellow",
  LIGHTYELLOW2: "lightyellow2",
  IVORY3: "ivory3",
  LIGHTYELLOW3: "lightyellow3",
  IVORY4: "ivory4",
  LIGHTYELLOW4: "lightyellow4",
  YELLOW: "yellow",
  YELLOW1: "yellow1",
  YELLOW2: "yellow2",
  YELLOW3: "yellow3",
  YELLOW4: "yellow4",
  OLIVE: "olive",
  DARKKHAKI: "darkkhaki",
  KHAKI2: "khaki2",
  LEMONCHIFFON4: "lemonchiffon4",
  KHAKI1: "khaki1",
  KHAKI3: "khaki3",
  KHAKI4: "khaki4",
  PALEGOLDENROD: "palegoldenrod",
  LEMONCHIFFON: "lemonchiffon",
  LEMONCHIFFON1: "lemonchiffon1",
  KHAKI: "khaki",
  LEMONCHIFFON3: "lemonchiffon3",
  LEMONCHIFFON2: "lemonchiffon2",
  MEDIUMGOLDENROD: "mediumgoldenrod",
  CORNSILK4: "cornsilk4",
  GOLD: "gold",
  GOLD1: "gold1",
  GOLD2: "gold2",
  GOLD3: "gold3",
  GOLD4: "gold4",
  LIGHTGOLDENROD: "lightgoldenrod",
  LIGHTGOLDENROD4: "lightgoldenrod4",
  LIGHTGOLDENROD1: "lightgoldenrod1",
  LIGHTGOLDENROD3: "lightgoldenrod3",
  LIGHTGOLDENROD2: "lightgoldenrod2",
  CORNSILK3: "cornsilk3",
  CORNSILK2: "cornsilk2",
  CORNSILK: "cornsilk",
  CORNSILK1: "cornsilk1",
  GOLDENROD: "goldenrod",
  GOLDENROD1: "goldenrod1",
  GOLDENROD2: "goldenrod2",
  GOLDENROD3: "goldenrod3",
  GOLDENROD4: "goldenrod4",
  DARKGOLDENROD: "darkgoldenrod",
  DARKGOLDENROD1: "darkgoldenrod1",
  DARKGOLDENROD2: "darkgoldenrod2",
  DARKGOLDENROD3: "darkgoldenrod3",
  DARKGOLDENROD4: "darkgoldenrod4",
  FLORALWHITE: "floralwhite",
  WHEAT2: "wheat2",
  OLDLACE: "oldlace",
  WHEAT: "wheat",
  WHEAT1: "wheat1",
  WHEAT3: "wheat3",
  ORANGE: "orange",
  ORANGE1: "orange1",
  ORANGE2: "orange2",
  ORANGE3: "orange3",
  ORANGE4: "orange4",
  WHEAT4: "wheat4",
  MOCCASIN: "moccasin",
  PAPAYAWHIP: "papayawhip",
  NAVAJOWHITE3: "navajowhite3",
  BLANCHEDALMOND: "blanchedalmond",
  NAVAJOWHITE: "navajowhite",
  NAVAJOWHITE1: "navajowhite1",
  NAVAJOWHITE2: "navajowhite2",
  NAVAJOWHITE4: "navajowhite4",
  ANTIQUEWHITE4: "antiquewhite4",
  ANTIQUEWHITE: "antiquewhite",
  TAN: "tan",
  BISQUE4: "bisque4",
  BURLYWOOD: "burlywood",
  ANTIQUEWHITE2: "antiquewhite2",
  BURLYWOOD1: "burlywood1",
  BURLYWOOD3: "burlywood3",
  BURLYWOOD2: "burlywood2",
  ANTIQUEWHITE1: "antiquewhite1",
  BURLYWOOD4: "burlywood4",
  ANTIQUEWHITE3: "antiquewhite3",
  DARKORANGE: "darkorange",
  BISQUE2: "bisque2",
  BISQUE: "bisque",
  BISQUE1: "bisque1",
  BISQUE3: "bisque3",
  DARKORANGE1: "darkorange1",
  LINEN: "linen",
  DARKORANGE2: "darkorange2",
  DARKORANGE3: "darkorange3",
  DARKORANGE4: "darkorange4",
  PERU: "peru",
  TAN1: "tan1",
  TAN2: "tan2",
  TAN3: "tan3",
  TAN4: "tan4",
  PEACHPUFF: "peachpuff",
  PEACHPUFF1: "peachpuff1",
  PEACHPUFF4: "peachpuff4",
  PEACHPUFF2: "peachpuff2",
  PEACHPUFF3: "peachpuff3",
  SANDYBROWN: "sandybrown",
  SEASHELL4: "seashell4",
  SEASHELL2: "seashell2",
  SEASHELL3: "seashell3",
  CHOCOLATE: "chocolate",
  CHOCOLATE1: "chocolate1",
  CHOCOLATE2: "chocolate2",
  CHOCOLATE3: "chocolate3",
  CHOCOLATE4: "chocolate4",
  SADDLEBROWN: "saddlebrown",
  SEASHELL: "seashell",
  SEASHELL1: "seashell1",
  SIENNA4: "sienna4",
  SIENNA: "sienna",
  SIENNA1: "sienna1",
  SIENNA2: "sienna2",
  SIENNA3: "sienna3",
  LIGHTSALMON3: "lightsalmon3",
  LIGHTSALMON: "lightsalmon",
  LIGHTSALMON1: "lightsalmon1",
  LIGHTSALMON4: "lightsalmon4",
  LIGHTSALMON2: "lightsalmon2",
  CORAL: "coral",
  ORANGERED: "orangered",
  ORANGERED1: "orangered1",
  ORANGERED2: "orangered2",
  ORANGERED3: "orangered3",
  ORANGERED4: "orangered4",
  DARKSALMON: "darksalmon",
  SALMON1: "salmon1",
  SALMON2: "salmon2",
  SALMON3: "salmon3",
  SALMON4: "salmon4",
  CORAL1: "coral1",
  CORAL2: "coral2",
  CORAL3: "coral3",
  CORAL4: "coral4",
  TOMATO4: "tomato4",
  TOMATO: "tomato",
  TOMATO1: "tomato1",
  TOMATO2: "tomato2",
  TOMATO3: "tomato3",
  MISTYROSE4: "mistyrose4",
  MISTYROSE2: "mistyrose2",
  MISTYROSE: "mistyrose",
  MISTYROSE1: "mistyrose1",
  SALMON: "salmon",
  MISTYROSE3: "mistyrose3",
  WHITE: "white",
  GRAY100: "gray100",
  GREY100: "grey100",
  GRAY99: "gray99",
  GREY99: "grey99",
  GRAY98: "gray98",
  GREY98: "grey98",
  GRAY97: "gray97",
  GREY97: "grey97",
  GRAY96: "gray96",
  GREY96: "grey96",
  WHITESMOKE: "whitesmoke",
  GRAY95: "gray95",
  GREY95: "grey95",
  GRAY94: "gray94",
  GREY94: "grey94",
  GRAY93: "gray93",
  GREY93: "grey93",
  GRAY92: "gray92",
  GREY92: "grey92",
  GRAY91: "gray91",
  GREY91: "grey91",
  GRAY90: "gray90",
  GREY90: "grey90",
  GRAY89: "gray89",
  GREY89: "grey89",
  GRAY88: "gray88",
  GREY88: "grey88",
  GRAY87: "gray87",
  GREY87: "grey87",
  GAINSBORO: "gainsboro",
  GRAY86: "gray86",
  GREY86: "grey86",
  GRAY85: "gray85",
  GREY85: "grey85",
  GRAY84: "gray84",
  GREY84: "grey84",
  GRAY83: "gray83",
  GREY83: "grey83",
  LIGHTGRAY: "lightgray",
  LIGHTGREY: "lightgrey",
  GRAY82: "gray82",
  GREY82: "grey82",
  GRAY81: "gray81",
  GREY81: "grey81",
  GRAY80: "gray80",
  GREY80: "grey80",
  GRAY79: "gray79",
  GREY79: "grey79",
  GRAY78: "gray78",
  GREY78: "grey78",
  GRAY77: "gray77",
  GREY77: "grey77",
  GRAY76: "gray76",
  GREY76: "grey76",
  SILVER: "silver",
  GRAY75: "gray75",
  GREY75: "grey75",
  GRAY74: "gray74",
  GREY74: "grey74",
  GRAY73: "gray73",
  GREY73: "grey73",
  GRAY72: "gray72",
  GREY72: "grey72",
  GRAY71: "gray71",
  GREY71: "grey71",
  GRAY70: "gray70",
  GREY70: "grey70",
  GRAY69: "gray69",
  GREY69: "grey69",
  GRAY68: "gray68",
  GREY68: "grey68",
  GRAY67: "gray67",
  GREY67: "grey67",
  DARKGRAY: "darkgray",
  DARKGREY: "darkgrey",
  GRAY66: "gray66",
  GREY66: "grey66",
  GRAY65: "gray65",
  GREY65: "grey65",
  GRAY64: "gray64",
  GREY64: "grey64",
  GRAY63: "gray63",
  GREY63: "grey63",
  GRAY62: "gray62",
  GREY62: "grey62",
  GRAY61: "gray61",
  GREY61: "grey61",
  GRAY60: "gray60",
  GREY60: "grey60",
  GRAY59: "gray59",
  GREY59: "grey59",
  GRAY58: "gray58",
  GREY58: "grey58",
  GRAY57: "gray57",
  GREY57: "grey57",
  GRAY56: "gray56",
  GREY56: "grey56",
  GRAY55: "gray55",
  GREY55: "grey55",
  GRAY54: "gray54",
  GREY54: "grey54",
  GRAY53: "gray53",
  GREY53: "grey53",
  GRAY52: "gray52",
  GREY52: "grey52",
  GRAY51: "gray51",
  GREY51: "grey51",
  FRACTAL: "fractal",
  GRAY50: "gray50",
  GREY50: "grey50",
  GRAY: "gray",
  GREY: "grey",
  GRAY49: "gray49",
  GREY49: "grey49",
  GRAY48: "gray48",
  GREY48: "grey48",
  GRAY47: "gray47",
  GREY47: "grey47",
  GRAY46: "gray46",
  GREY46: "grey46",
  GRAY45: "gray45",
  GREY45: "grey45",
  GRAY44: "gray44",
  GREY44: "grey44",
  GRAY43: "gray43",
  GREY43: "grey43",
  GRAY42: "gray42",
  GREY42: "grey42",
  DIMGRAY: "dimgray",
  DIMGREY: "dimgrey",
  GRAY41: "gray41",
  GREY41: "grey41",
  GRAY40: "gray40",
  GREY40: "grey40",
  GRAY39: "gray39",
  GREY39: "grey39",
  GRAY38: "gray38",
  GREY38: "grey38",
  GRAY37: "gray37",
  GREY37: "grey37",
  GRAY36: "gray36",
  GREY36: "grey36",
  GRAY35: "gray35",
  GREY35: "grey35",
  GRAY34: "gray34",
  GREY34: "grey34",
  GRAY33: "gray33",
  GREY33: "grey33",
  GRAY32: "gray32",
  GREY32: "grey32",
  GRAY31: "gray31",
  GREY31: "grey31",
  GRAY30: "gray30",
  GREY30: "grey30",
  GRAY29: "gray29",
  GREY29: "grey29",
  GRAY28: "gray28",
  GREY28: "grey28",
  GRAY27: "gray27",
  GREY27: "grey27",
  GRAY26: "gray26",
  GREY26: "grey26",
  GRAY25: "gray25",
  GREY25: "grey25",
  GRAY24: "gray24",
  GREY24: "grey24",
  GRAY23: "gray23",
  GREY23: "grey23",
  GRAY22: "gray22",
  GREY22: "grey22",
  GRAY21: "gray21",
  GREY21: "grey21",
  GRAY20: "gray20",
  GREY20: "grey20",
  GRAY19: "gray19",
  GREY19: "grey19",
  GRAY18: "gray18",
  GREY18: "grey18",
  GRAY17: "gray17",
  GREY17: "grey17",
  GRAY16: "gray16",
  GREY16: "grey16",
  GRAY15: "gray15",
  GREY15: "grey15",
  GRAY14: "gray14",
  GREY14: "grey14",
  GRAY13: "gray13",
  GREY13: "grey13",
  GRAY12: "gray12",
  GREY12: "grey12",
  GRAY11: "gray11",
  GREY11: "grey11",
  GRAY10: "gray10",
  GREY10: "grey10",
  GRAY9: "gray9",
  GREY9: "grey9",
  GRAY8: "gray8",
  GREY8: "grey8",
  GRAY7: "gray7",
  GREY7: "grey7",
  GRAY6: "gray6",
  GREY6: "grey6",
  GRAY5: "gray5",
  GREY5: "grey5",
  GRAY4: "gray4",
  GREY4: "grey4",
  GRAY3: "gray3",
  GREY3: "grey3",
  GRAY2: "gray2",
  GREY2: "grey2",
  GRAY1: "gray1",
  GREY1: "grey1",
  BLACK: "black",
  GRAY0: "gray0",
  GREY0: "grey0",
  OPAQUE: "opaque",
  NONE: "none",
  TRANSPARENT: "transparent"
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/background.js
function border() {
  return new BackgroundAutoBorderQualifier();
}
function auto3() {
  return new BackgroundQualifier("auto");
}
function borderGradient() {
  return new BackgroundBorderGradientQualifier();
}
function predominantGradient() {
  return new BackgroundPredominantGradientQualifier();
}
function predominant() {
  return new BackgroundAutoPredominantQualifier();
}
function color(colorStr) {
  return new BackgroundQualifier(prepareColor(colorStr));
}
function blurred() {
  return new BlurredBackgroundAction_default();
}
function generativeFill() {
  return new BackgroundGenerativeFillQualifier();
}
var Background = {
  auto: auto3,
  border,
  borderGradient,
  predominantGradient,
  predominant,
  color,
  blurred,
  generativeFill
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/audioFrequency.js
function ORIGINAL() {
  return "iaf";
}
function FREQ192000() {
  return 192e3;
}
function FREQ176400() {
  return 176400;
}
function FREQ96000() {
  return 96e3;
}
function FREQ88200() {
  return 88200;
}
function FREQ48000() {
  return 48e3;
}
function FREQ8000() {
  return 8e3;
}
function FREQ11025() {
  return 11025;
}
function FREQ16000() {
  return 16e3;
}
function FREQ22050() {
  return 22050;
}
function FREQ32000() {
  return 32e3;
}
function FREQ37800() {
  return 37800;
}
function FREQ44056() {
  return 44056;
}
function FREQ44100() {
  return 44100;
}
function FREQ47250() {
  return 47250;
}
var AudioFrequency = {
  FREQ8000,
  FREQ11025,
  FREQ16000,
  FREQ22050,
  FREQ32000,
  FREQ37800,
  FREQ44056,
  FREQ44100,
  FREQ47250,
  FREQ48000,
  FREQ88200,
  FREQ96000,
  FREQ176400,
  FREQ192000,
  ORIGINAL
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/audioCodec.js
function none2() {
  return "none";
}
function aac() {
  return "aac";
}
function vorbis() {
  return "vorbis";
}
function mp3() {
  return "mp3";
}
function opus() {
  return "opus";
}
var AudioCodec = {
  aac,
  mp3,
  opus,
  none: none2,
  vorbis
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/aspectRatio.js
function ar1X1() {
  return new AspectRatioQualifierValue("1:1");
}
function ar5X4() {
  return new AspectRatioQualifierValue("5:4");
}
function ar4X3() {
  return new AspectRatioQualifierValue("4:3");
}
function ar3X2() {
  return new AspectRatioQualifierValue("3:2");
}
function ar16X9() {
  return new AspectRatioQualifierValue("16:9");
}
function ar3X1() {
  return new AspectRatioQualifierValue("3:1");
}
function ignoreInitialAspectRatio2() {
  return ignoreInitialAspectRatio();
}
var AspectRatio = {
  ar1X1,
  ar5X4,
  ar3X1,
  ar3X2,
  ar4X3,
  ar16X9,
  ignoreInitialAspectRatio: ignoreInitialAspectRatio2
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/artisticFilter.js
function alDente() {
  return "al_dente";
}
function athena() {
  return "athena";
}
function audrey() {
  return "audrey";
}
function aurora() {
  return "aurora";
}
function daguerre() {
  return "daguerre";
}
function eucalyptus() {
  return "eucalyptus";
}
function fes() {
  return "fes";
}
function frost() {
  return "frost";
}
function hairspray() {
  return "hairspray";
}
function hokusai() {
  return "hokusai";
}
function incognito() {
  return "incognito";
}
function linen() {
  return "linen";
}
function peacock() {
  return "peacock";
}
function primavera() {
  return "primavera";
}
function quartz() {
  return "quartz";
}
function redRock() {
  return "red_rock";
}
function refresh() {
  return "refresh";
}
function sizzle() {
  return "sizzle";
}
function sonnet() {
  return "sonnet";
}
function ukulele() {
  return "ukulele";
}
function zorro() {
  return "zorro";
}
var ArtisticFilter = {
  alDente,
  athena,
  audrey,
  aurora,
  daguerre,
  eucalyptus,
  hairspray,
  hokusai,
  peacock,
  primavera,
  quartz,
  incognito,
  redRock,
  sizzle,
  fes,
  linen,
  refresh,
  sonnet,
  ukulele,
  frost,
  zorro
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/animatedFormat/AnimatedFormatQualifierValue.js
var AnimatedFormatQualifierValue = class extends QualifierValue {
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/animatedFormat.js
function auto4() {
  return new AnimatedFormatQualifierValue("auto");
}
function gif2() {
  return new AnimatedFormatQualifierValue("gif");
}
function webp2() {
  return new AnimatedFormatQualifierValue("webp");
}
function png2() {
  return new AnimatedFormatQualifierValue("png");
}
var AnimatedFormat = { auto: auto4, gif: gif2, webp: webp2, png: png2 };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/chromaSubSampling.js
function chroma444() {
  return 444;
}
function chroma420() {
  return 420;
}
var ChromaSubSampling = {
  chroma444,
  chroma420
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/dpr.js
function auto5() {
  return "auto";
}
var Dpr = {
  auto: auto5
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/BaseSource.js
var BaseSource = class extends QualifierModel {
  /**
   * @description Utility function to encode an asset publicID in an overlay
   * @protected
   * @example
   * encodeAssetPublicID('foo/bar'); // -> foo:bar
   */
  encodeAssetPublicID(publicID) {
    return publicID.replace(/\//g, ":");
  }
  /**
   * @description
   * Apply a transformation on the image source of the layer
   * @param {SDK.ImageTransformation} t An image transformation to apply to the layer
   * @returns {this}
   */
  transformation(t) {
    this._qualifierModel.transformation = t.toJson();
    this._transformation = t;
    return this;
  }
  /**
   * @description Returns the Transformation of the source
   * @return {SDK.Transformation}
   */
  getTransformation() {
    return this._transformation;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/VideoSource.js
var VideoSource = class extends BaseSource {
  constructor(publicID) {
    super();
    this._publicID = publicID;
    this._qualifierModel = {
      publicId: publicID,
      sourceType: "video"
    };
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    const encodedPublicID = this.encodeAssetPublicID(this._publicID);
    return `${layerType}_video:${encodedPublicID}`;
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { publicId, transformation } = qualifierModel;
    const result = new this(publicId);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/ImageSource.js
var ImageSource = class extends BaseSource {
  constructor(publicID) {
    super();
    this._publicID = publicID;
    this._qualifierModel = {
      publicId: publicID,
      sourceType: "image"
    };
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    const encodedPublicID = this.encodeAssetPublicID(this._publicID);
    if (this._format) {
      return `${layerType}_${encodedPublicID}.${this._format.toString()}`;
    } else {
      return `${layerType}_${encodedPublicID}`;
    }
  }
  /**
   * @description
   * Apply a format for the image source of the layer
   * @param {FormatQualifier} format A to apply to the layered image, see more {@link Qualifiers.Format|here}
   * @returns {this}
   */
  format(format2) {
    this._format = format2;
    return this;
  }
  toJson() {
    const result = super.toJson();
    if (result.publicId && this._format) {
      result.publicId = `${result.publicId}.${this._format.toString()}`;
    }
    return result;
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { publicId, transformation } = qualifierModel;
    const result = new this(publicId);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/serializeCloudinaryCharacters.js
function serializeCloudinaryCharacters(str = "") {
  return str.replace(/,/g, "%2C").replace(/\//g, "%2F");
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/IStrokeModel.js
function isISolidStrokeModel(obj) {
  return typeof obj === "object" && obj.width != null && obj.color != null;
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/textStyle.js
var TextStyle = class extends QualifierModel {
  /**
   * @param {string} fontFamily The font family
   * @param {number | string} fontSize The font size
   */
  constructor(fontFamily, fontSize) {
    super();
    if (!fontFamily || !fontSize) {
      throw `You must provide a fontFamily and fontSize to a TextStyle`;
    }
    this._qualifierModel.fontFamily = fontFamily;
    this._qualifierModel.fontSize = fontSize;
  }
  /**
   * @param {number} spacing The spacing between multiple lines in pixels.
   */
  lineSpacing(spacing) {
    this._qualifierModel.lineSpacing = spacing;
    return this;
  }
  /**
   * @param spacing The spacing between the letters, in pixels.
   */
  letterSpacing(spacing) {
    this._qualifierModel.letterSpacing = spacing;
    return this;
  }
  /**
   * The antialias setting to apply to the text. When this parameter is not specified, the default antialiasing for the subsystem and target device are applied.
   * @param {FontAntialiasType|string} antiAlias
   */
  fontAntialias(antiAlias) {
    this._qualifierModel.fontAntialias = antiAlias;
    return this;
  }
  /**
   * The name of any universally available font or a custom font, specified as the public ID of a raw, authenticated font in your account.
   * For details on custom fonts, see {@link https://cloudinary.com/documentation/layers#custom_fonts|Using custom fonts for text overlays}.
   * @param {string} fontFamilyName
   */
  fontFamily(fontFamilyName) {
    this._qualifierModel.fontFamily = fontFamilyName;
    return this;
  }
  /**
   * @param {number} fontSize The font size
   */
  fontSize(fontSize) {
    this._qualifierModel.fontSize = fontSize;
    return this;
  }
  /**
   * @param {FontWeightType|string} fontWeight The font weight
   */
  fontWeight(fontWeight) {
    this._qualifierModel.fontWeight = fontWeight;
    return this;
  }
  /**
   *
   * @param {string} fontStyle The font style.
   */
  fontStyle(fontStyle) {
    this._qualifierModel.fontStyle = fontStyle;
    return this;
  }
  /**
   * @param {string} fontHinting The outline hinting style to apply to the text. When this parameter is not specified, the default hint style for the font and target device are applied.
   */
  fontHinting(fontHinting) {
    this._qualifierModel.fontHinting = fontHinting;
    return this;
  }
  /**
   *
   * @param {TextDecorationType|string} textDecoration The font decoration type.
   */
  textDecoration(textDecoration) {
    this._qualifierModel.textDecoration = textDecoration;
    return this;
  }
  /**
   * @param {TextAlignmentType|string} textAlignment The text alignment
   */
  textAlignment(textAlignment) {
    this._qualifierModel.textAlignment = textAlignment;
    return this;
  }
  /**
   * @description Whether to include an outline stroke. Set the color and weight of the stroke
   */
  stroke(textStroke) {
    if (textStroke) {
      const strokeStyle = textStroke.split("_");
      this._qualifierModel.stroke = {
        width: +strokeStyle[1].replace("px", ""),
        color: strokeStyle[strokeStyle.length - 1]
      };
    } else {
      this._qualifierModel.stroke = true;
    }
    return this;
  }
  toString() {
    const { stroke } = this._qualifierModel;
    let strokeStr = "";
    if (stroke) {
      strokeStr = isISolidStrokeModel(stroke) ? `stroke_${solid(stroke.width, stroke.color)}` : "stroke";
    }
    return [
      `${serializeCloudinaryCharacters(this._qualifierModel.fontFamily)}_${this._qualifierModel.fontSize}`,
      this._qualifierModel.fontWeight !== normal2() && this._qualifierModel.fontWeight,
      this._qualifierModel.fontStyle !== normal3() && this._qualifierModel.fontStyle,
      this._qualifierModel.textDecoration !== normal() && this._qualifierModel.textDecoration,
      this._qualifierModel.textAlignment,
      strokeStr,
      this._qualifierModel.letterSpacing && `letter_spacing_${this._qualifierModel.letterSpacing}`,
      this._qualifierModel.lineSpacing && `line_spacing_${this._qualifierModel.lineSpacing}`,
      this._qualifierModel.fontAntialias && `antialias_${this._qualifierModel.fontAntialias}`,
      this._qualifierModel.fontHinting && `hinting_${this._qualifierModel.fontHinting}`
    ].filter((a) => a).join("_");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/BaseTextSource.js
var BaseTextSource = class extends BaseSource {
  constructor(text2, textStyle) {
    super();
    this.type = "text";
    this.text = text2;
    this._textStyle = textStyle;
    this._qualifierModel.sourceType = "text";
    this._qualifierModel.text = text2;
    if (textStyle instanceof TextStyle) {
      this._qualifierModel.textStyle = textStyle.toJson();
    }
  }
  encodeText(text2) {
    return serializeCloudinaryCharacters(text2);
  }
  textColor(color2) {
    this._textColor = color2;
    this._qualifierModel.textColor = color2;
    return this;
  }
  backgroundColor(bgColor) {
    this._backgroundColor = bgColor;
    this._qualifierModel.backgroundColor = bgColor;
    return this;
  }
  textFit(textFit) {
    this._textFit = textFit;
    return this;
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    const layerParam = [
      this.type,
      this._textStyle && this._textStyle.toString(),
      this.encodeText(this.text)
    ].filter((a) => a).join(":");
    const tmpAction = new Action();
    tmpAction.addQualifier(new Qualifier(layerType, layerParam));
    this._textColor && tmpAction.addQualifier(new Qualifier("co", prepareColor(this._textColor)));
    this._backgroundColor && tmpAction.addQualifier(new Qualifier("b", prepareColor(this._backgroundColor)));
    this._textFit && tmpAction.addQualifier(this._textFit);
    return tmpAction.toString();
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/SubtitlesSource.js
var SubtitlesSource = class extends BaseTextSource {
  constructor(fileName) {
    super(fileName);
    this.type = "subtitles";
    this._qualifierModel = {
      sourceType: "subtitles",
      publicId: fileName
    };
  }
  /**
   * @description Set the textStyle for the subtitles layer
   * @param {TextStyle} textStyle
   */
  textStyle(textStyle) {
    this._textStyle = textStyle;
    this._qualifierModel.textStyle = textStyle.toJson();
    return this;
  }
  /**
   *
   * @description Used within getOpenSourceString of TextSource, this function overwrites the default encoding behaviour
   * Subtitle file names require a different encoding than texts
   * @param text
   * @example
   * encodeText('foo/bar'); // -> foo:bar
   */
  encodeText(text2) {
    return text2.replace(/\//g, ":");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/base64Encode.js
function base64Encode(input) {
  let encodedResult = "";
  if (typeof window !== "undefined") {
    encodedResult = btoa(encodeURI(decodeURI(input)));
  } else {
    encodedResult = global.Buffer.from(input).toString("base64");
  }
  return encodedResult.replace(/\+/g, "-").replace(/\//g, "_");
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/FetchSource.js
var FetchSource = class extends BaseSource {
  constructor(remoteURL) {
    super();
    this._qualifierModel = {
      sourceType: "fetch",
      url: remoteURL
    };
    this._remoteURL = remoteURL;
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    if (this._format) {
      return `${layerType}_fetch:${base64Encode(this._remoteURL)}.${this._format.toString()}`;
    } else {
      return `${layerType}_fetch:${base64Encode(this._remoteURL)}`;
    }
  }
  /**
   * @description
   * Apply a format for the image source of the layer
   * @param {FormatQualifier} format A to apply to the layered image, see more {@link Qualifiers.Format|here}
   * @returns {this}
   */
  format(format2) {
    this._qualifierModel.format = format2.toString();
    this._format = format2;
    return this;
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { url, transformation, format: format2 } = qualifierModel;
    const result = new this(url);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    if (format2) {
      result.format(new FormatQualifier(format2));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createTextStyleFromModel.js
function createTextStyleFromModel(textStyleModel) {
  const { fontFamily, fontSize, fontWeight, fontStyle, fontAntialias, fontHinting, textDecoration, textAlignment, stroke, letterSpacing, lineSpacing } = textStyleModel;
  const result = new TextStyle(fontFamily, fontSize);
  if (fontWeight) {
    result.fontWeight(fontWeight);
  }
  if (fontStyle) {
    result.fontStyle(fontStyle);
  }
  if (fontAntialias) {
    result.fontAntialias(fontAntialias);
  }
  if (fontHinting) {
    result.fontHinting(fontHinting);
  }
  if (textDecoration) {
    result.textDecoration(textDecoration);
  }
  if (textAlignment) {
    result.textAlignment(textAlignment);
  }
  if (stroke) {
    result.stroke();
    if (typeof stroke !== "boolean") {
      result.stroke(solid(stroke.width, stroke.color));
    }
  }
  if (letterSpacing) {
    result.letterSpacing(letterSpacing);
  }
  if (lineSpacing) {
    result.lineSpacing(lineSpacing);
  }
  return result;
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/TextSource.js
var TextSource = class extends BaseTextSource {
  constructor(fileName, textStyle) {
    super(fileName, textStyle);
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { text: text2, textStyle, textColor, backgroundColor, transformation } = qualifierModel;
    const result = new this(text2, textStyle ? createTextStyleFromModel(textStyle) : void 0);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    if (textColor) {
      result.textColor(textColor);
    }
    if (backgroundColor) {
      result.backgroundColor(backgroundColor);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source.js
function image(publicID) {
  return new ImageSource(publicID);
}
function text(text2, textStyle) {
  return new TextSource(text2, textStyle);
}
function video(publicID) {
  return new VideoSource(publicID);
}
function subtitles(fileName) {
  return new SubtitlesSource(fileName);
}
function fetch(remoteURL) {
  return new FetchSource(remoteURL);
}
var Source = { image, text, video, subtitles, fetch };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/GradientFade.js
function symmetric() {
  return "symmetric";
}
function symmetricPad() {
  return "symmetric_pad";
}
var GradientFade = {
  symmetric,
  symmetricPad
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createBackgroundFromModel.js
function createBlurredBackground(backgroundModel) {
  const { brightness: brightness2, intensity } = backgroundModel;
  const result = Background.blurred();
  if (brightness2 || brightness2 == 0) {
    result.brightness(brightness2);
  }
  if (intensity || intensity == 0) {
    result.intensity(intensity);
  }
  return result;
}
function createGradientBackground(background, backgroundModel) {
  const { gradientColors, gradientDirection, contrast: contrast2, palette } = backgroundModel;
  if (contrast2) {
    background.contrast();
  }
  if (palette) {
    background.palette(...palette);
  }
  if (gradientColors) {
    background.gradientColors(+gradientColors);
  }
  if (gradientDirection) {
    background.gradientDirection(gradientDirection);
  }
  return background;
}
function createContrastPaletteBackground(background, backgroundModel) {
  const { contrast: contrast2, palette } = backgroundModel;
  if (contrast2) {
    background.contrast();
  }
  if (palette) {
    background.palette(...palette);
  }
  return background;
}
function createGenerativeFillBackground(background, backgroundModel) {
  const { prompt } = backgroundModel;
  if (prompt) {
    background.prompt(prompt);
  }
  return background;
}
function createBackgroundFromModel(backgroundModel) {
  const { backgroundType } = backgroundModel;
  switch (backgroundType) {
    case "auto":
      return auto3();
    case "blurred":
      return createBlurredBackground(backgroundModel);
    case "border":
      return createContrastPaletteBackground(border(), backgroundModel);
    case "borderGradient":
      return createGradientBackground(borderGradient(), backgroundModel);
    case "predominant":
      return createContrastPaletteBackground(predominant(), backgroundModel);
    case "predominantGradient":
      return createGradientBackground(predominantGradient(), backgroundModel);
    case "generativeFill":
      return createGenerativeFillBackground(generativeFill(), backgroundModel);
    default:
      return color(backgroundModel.color);
  }
}

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizePadAction.js
var ResizePadAction = class extends ResizeAdvancedAction {
  /**
   * @description Sets the background.
   * @param {Qualifiers.Background} backgroundQualifier Defines the background color to use instead of
   * transparent background areas or when resizing with padding.
   */
  background(backgroundQualifier) {
    this._actionModel.background = createBackgroundModel(backgroundQualifier);
    return this.addQualifier(backgroundQualifier);
  }
  /**
   * @description Horizontal position for custom-coordinates based padding.
   * @param {number} x The x position.
   */
  offsetX(x) {
    this._actionModel.x = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Vertical position for custom-coordinates based padding
   * @param {number} y The y position.
   */
  offsetY(y) {
    this._actionModel.y = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.background && result.background(createBackgroundFromModel(actionModel.background));
    actionModel.x && result.offsetX(actionModel.x);
    actionModel.y && result.offsetY(actionModel.y);
    actionModel.zoom && result.zoom(actionModel.zoom);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeScaleAction.js
var ResizeScaleAction = class extends ResizeSimpleAction {
  /**
   * @description Changes the aspect ratio of an image while retaining all important content and avoiding unnatural
   * distortions.
   * @return {this}
   */
  liquidRescaling() {
    return this.addQualifier(new GravityQualifier("liquid"));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ThumbnailAction.js
var ThumbResizeAction = class extends ResizeAdvancedAction {
  /**
   * @description Controls how much of the original image surrounding the face to keep when using either the 'crop' or 'thumb' cropping modes with face detection.
   * @param {number | string} z The zoom factor. (Default: 1.0)
   */
  zoom(z) {
    this._actionModel.zoom = z;
    return this.addQualifier(new Qualifier("z", z));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.zoom && result.zoom(actionModel.zoom);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeCropAction.js
var ResizeCropAction = class extends ResizeAdvancedAction {
  /**
   * @description Horizontal position for custom-coordinates based cropping.
   * @param {number} x The x position.
   */
  x(x) {
    this._actionModel.x = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Vertical position for custom-coordinates based cropping
   * @param {number} y The y position.
   */
  y(y) {
    this._actionModel.y = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  /**
   * @description Controls how much of the original image surrounding the face to keep when using either the 'crop' or 'thumb' cropping modes with face detection.
   * @param {number | string} z The zoom factor. (Default: 1.0)
   */
  zoom(z) {
    this._actionModel.zoom = z;
    return this.addQualifier(new Qualifier("z", z));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.x && result.x(actionModel.x);
    actionModel.y && result.y(actionModel.y);
    actionModel.zoom && result.zoom(actionModel.zoom);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeFillAction.js
var ResizeFillAction = class extends ResizeAdvancedAction {
  /**
   * @description Absolute X position when used with Gravity.xyCenter {@link Qualifiers.Gravity.GravityQualifier}}
   * @param {number} x The x position.
   */
  x(x) {
    this._actionModel.x = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Absolute Y position when used with Gravity.xyCenter {@link Qualifiers.Gravity.GravityQualifier}}
   * @param {number} y The y position.
   */
  y(y) {
    this._actionModel.y = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  static fromJson(actionModel) {
    const result = super.fromJson.apply(this, [actionModel]);
    actionModel.x && result.x(actionModel.x);
    actionModel.y && result.y(actionModel.y);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeLimitFitAction.js
var ResizeLimitFitAction = class extends ResizeSimpleAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeLimitFillAction.js
var ResizeLimitFillAction = class extends ResizeFillAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeLimitPadAction.js
var ResizeLimitPadAction = class extends ResizePadAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize/ResizeMinimumPadAction.js
var ResizeMinimumPadAction = class extends ResizePadAction {
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/resize.js
function scale(width, height) {
  return new ResizeScaleAction("scale", width, height);
}
function imaggaScale(width, height) {
  return new ResizeSimpleAction("imagga_scale", width, height);
}
function imaggaCrop(width, height) {
  return new ResizeSimpleAction("imagga_crop", width, height);
}
function crop(width, height) {
  return new ResizeCropAction("crop", width, height);
}
function fill2(width, height) {
  return new ResizeFillAction("fill", width, height);
}
function fit(width, height) {
  return new ResizeSimpleAction("fit", width, height);
}
function pad(width, height) {
  return new ResizePadAction("pad", width, height);
}
function limitFill(width, height) {
  return new ResizeLimitFillAction("lfill", width, height);
}
function limitFit(width, height) {
  return new ResizeLimitFitAction("limit", width, height);
}
function minimumPad(width, height) {
  return new ResizeMinimumPadAction("mpad", width, height);
}
function minimumFit(width, height) {
  return new ResizeSimpleAction("mfit", width, height);
}
function fillPad(width, height) {
  return new ResizePadAction("fill_pad", width, height);
}
function thumbnail(width, height) {
  return new ThumbResizeAction("thumb", width, height);
}
function limitPad(width, height) {
  return new ResizeLimitPadAction("lpad", width, height);
}
var Resize = {
  imaggaScale,
  imaggaCrop,
  crop,
  fill: fill2,
  scale,
  minimumPad,
  fit,
  pad,
  limitFit,
  thumbnail,
  limitFill,
  minimumFit,
  limitPad,
  fillPad
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/roundCorners/RoundCornersAction.js
var RoundCornersAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "roundCorners";
  }
  /**
   * @param {number} a
   * @param {number} b
   * @param {number} c
   * @param {number} d
   * @return {RoundCornersAction}
   */
  radius(a, b, c, d) {
    const qualifierValue = new QualifierValue();
    a !== void 0 && qualifierValue.addValue(a);
    b !== void 0 && qualifierValue.addValue(b);
    c !== void 0 && qualifierValue.addValue(c);
    d !== void 0 && qualifierValue.addValue(d);
    const definedRadiuses = [a, b, c, d].filter((r) => r !== void 0);
    this._radius = definedRadiuses;
    this._actionModel.radius = definedRadiuses;
    this.addQualifier(new Qualifier("r").addValue(qualifierValue));
    return this;
  }
  /**
   * @description Applies maximum rounding to the corners of the asset. An asset with square dimensions becomes a circle.
   */
  max() {
    this._radius = "max";
    this._actionModel.radius = "max";
    return this.addQualifier(new Qualifier("r", "max"));
  }
  getRadius() {
    return this._radius;
  }
  static fromJson(actionModel) {
    const { radius } = actionModel;
    const result = new this();
    if (Array.isArray(radius)) {
      result.radius(radius[0], radius[1], radius[2], radius[3]);
    }
    if (radius === "max") {
      result.max();
    }
    return result;
  }
};
var RoundCornersAction_default = RoundCornersAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/border.js
var BorderAction = class extends Action {
  /**
   * @description Adds a border of the specified type around an image or video.
   * @param {'solid'} borderType The type of border (currently only 'solid' is supported). Use values in {@link Qualifiers.Border|Border Values}.
   * @param {string} color The color of the border.
   * @param {number} borderWidth The width in pixels.
   */
  constructor(borderType, color2, borderWidth) {
    super();
    this._actionModel = {};
    this.borderType = borderType;
    this.borderColor = prepareColor(color2);
    this.borderWidth = borderWidth;
    this._actionModel = {
      color: prepareColor(color2),
      width: borderWidth,
      actionType: "border"
    };
  }
  /**
   * @description Sets the width of the border
   * @param {number | string} borderWidth The width in pixels.
   */
  width(borderWidth) {
    this.borderWidth = borderWidth;
    this._actionModel.width = borderWidth;
    return this;
  }
  /**
   * @description Sets the color of the border.
   * @param {string} borderColor The color of the border.
   */
  color(borderColor) {
    this.borderColor = prepareColor(borderColor);
    this._actionModel.color = prepareColor(borderColor);
    return this;
  }
  /**
   * @description Rounds the specified corners of an image.
   * @param {RoundCornersAction} roundCorners
   * @return {this}
   */
  roundCorners(roundCorners2) {
    this._roundCorners = roundCorners2;
    this._actionModel.radius = roundCorners2.getRadius();
    return this;
  }
  /**
   * @description Sets the style of the border.
   * @param {number | string} width The width in pixels.
   * @param {string} color The color of the border, e.g 'green', 'yellow'.
   * @return {this}
   */
  solid(width, color2) {
    this.borderType = "solid";
    this.borderColor = prepareColor(color2);
    this.borderWidth = width;
    this._actionModel.color = prepareColor(color2);
    this._actionModel.width = width;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue([`${this.borderWidth}px`, this.borderType, `${this.borderColor}`]).setDelimiter("_");
    this.addQualifier(new Qualifier("bo", qualifierValue));
    if (this._roundCorners) {
      this.addQualifier(this._roundCorners.qualifiers.get("r"));
    }
  }
  static fromJson(actionModel) {
    const { width, color: color2, radius } = actionModel;
    const result = new this("solid", color2, width);
    if (radius) {
      const roundCornersAction = (() => {
        if (radius === "max") {
          return new RoundCornersAction_default().max();
        }
        if (Array.isArray(radius)) {
          return new RoundCornersAction_default().radius(...radius);
        }
        return void 0;
      })();
      if (roundCornersAction) {
        result.roundCorners(roundCornersAction);
      }
    }
    return result;
  }
};
function solid2(width, color2) {
  return new BorderAction("solid", color2, width);
}
function roundCorners(roundCorners2) {
  const borderActionInstance = new BorderAction("solid", "transparent", 0);
  borderActionInstance.roundCorners(roundCorners2);
  return borderActionInstance;
}
var Border = {
  solid: solid2,
  roundCorners
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/roundCorners.js
function max() {
  return new RoundCornersAction_default().max();
}
function byRadius(a, b, c, d) {
  return new RoundCornersAction_default().radius(a, b, c, d);
}
var RoundCorners = { byRadius, max };

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Blur.js
var BlurAction = class extends Action {
  constructor(strength) {
    super();
    this._actionModel = {};
    this._strength = strength;
    this._actionModel.actionType = "blur";
    this._actionModel.strength = strength;
  }
  /**
   * @description Specifies the region to blur.
   * @param {NamedRegion} blurRegion
   */
  region(blurRegion) {
    this._region = blurRegion;
    this._actionModel.region = blurRegion.toJson();
    return this;
  }
  /**
   * @description Sets the strength of the blur effect.
   * @param {number | string} strength
   */
  strength(strength) {
    this._strength = strength;
    this._actionModel.strength = strength;
    return this;
  }
  prepareQualifiers() {
    const strength = this._strength ? `:${this._strength}` : "";
    if ("_region" in this) {
      const qualifiers = this._region.qualifiers;
      qualifiers.forEach((q) => this.addQualifier(q));
      if (this._region.regionType === "custom") {
        this.addQualifier(new Qualifier("e", `blur_region${strength}`));
      }
      if (this._region.regionType === "ocr_text") {
        this.addQualifier(new Qualifier("e", `blur_region${strength}`));
        this.addQualifier(new Qualifier("g", `ocr_text`));
      }
      if (this._region.regionType === "faces") {
        this.addQualifier(new Qualifier("e", `blur_faces${strength}`));
      }
    } else {
      this.addQualifier(new Qualifier("e", `blur${strength}`));
    }
  }
  static fromJson(actionModel) {
    const { strength, region } = actionModel;
    const result = new this(strength);
    strength && result.strength(strength);
    if (region && region.regionType === "faces") {
      result.region(faces());
    }
    if (region && region.regionType === "ocr_text") {
      result.region(ocr2());
    }
    if (region && region.regionType === "custom") {
      result.region(CustomRegion.fromJson(region));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Accelerate.js
var AccelerationEffectAction = class extends Action {
  constructor(rate) {
    super();
    this._actionModel = { actionType: "accelerate" };
    rate && this.rate(rate);
  }
  rate(rate) {
    this._actionModel.rate = rate;
    this._rate = rate;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue(["accelerate", this._rate]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
  static fromJson(actionModel) {
    const { rate } = actionModel;
    const result = new this();
    rate && result.rate(rate);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/SimpleEffectAction.js
var SimpleEffectAction = class extends Action {
  constructor(effectType, level) {
    super();
    this._actionModel = {};
    this._actionModel.actionType = EFFECT_MODE_TO_ACTION_TYPE_MAP[effectType] || effectType;
    const qualifierEffect = this.createEffectQualifier(effectType, level);
    this.addQualifier(qualifierEffect);
  }
  createEffectQualifier(effectType, level) {
    let qualifierValue;
    if (level) {
      qualifierValue = new QualifierValue([effectType, `${level}`]).setDelimiter(":");
    } else {
      qualifierValue = new QualifierValue(effectType);
    }
    return new Qualifier("e", qualifierValue);
  }
  static fromJson(actionModel) {
    const { actionType, level, strength } = actionModel;
    const effectType = ACTION_TYPE_TO_EFFECT_MODE_MAP[actionType] || actionType;
    const result = new this(effectType, level ? level : strength);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/LeveledEffectAction.js
var LeveledEffectAction = class extends SimpleEffectAction {
  constructor(effectType, level) {
    super(effectType, level);
    this.LEVEL_NAME = "level";
    this._actionModel = {};
    this.effectType = effectType;
    this._actionModel.actionType = EFFECT_MODE_TO_ACTION_TYPE_MAP[effectType] || effectType;
    if (level) {
      this.setLevel(level);
    }
  }
  /**
   *
   * @description Sets the effect level for the action
   * @param {string | number} level - The strength of the effect
   * @protected
   */
  setLevel(level) {
    this._actionModel[this.LEVEL_NAME] = level;
    const qualifierEffect = this.createEffectQualifier(this.effectType, level);
    this.addQualifier(qualifierEffect);
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Loop.js
var LoopEffectAction = class extends LeveledEffectAction {
  additionalIterations(value) {
    this._actionModel.iterations = value;
    const qualifierEffect = this.createEffectQualifier(this.effectType, value);
    this.addQualifier(qualifierEffect);
    return this;
  }
  static fromJson(actionModel) {
    const { actionType, iterations } = actionModel;
    const result = new this(actionType, iterations);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Cartoonify.js
var CartoonifyEffect = class extends Action {
  constructor(effectName, strength) {
    super();
    this._actionModel = {};
    this.cartoonifyStrength = strength;
    this.effectName = effectName;
    this._actionModel.actionType = effectName;
  }
  /**
   * @description Sets the thickness of the lines.
   * @param {number} lineStrength The thickness of the lines. (Range: 0 to 100, Server default: 50)
   * @return {this}
   */
  lineStrength(lineStrength) {
    this.cartoonifyStrength = lineStrength;
    this._actionModel.lineStrength = lineStrength;
    return this;
  }
  /**
   * @description Achieves a black and white cartoon effect.
   * @return {this}
   */
  blackwhite() {
    this._actionModel.blackAndWhite = true;
    this.colorReduction = "bw";
    return this;
  }
  /**
   * @description
   * Sets the decrease in the number of colors and corresponding saturation boost of the remaining colors. <br/>
   * Higher reduction values result in a less realistic look.
   * @param {number } level The decrease in the number of colors and corresponding saturation boost of the remaining colors. (Range: 0 to 100, Server default: automatically adjusts according to the line_strength value). Set to 'bw' for a black and white cartoon effect.
   * @return {this}
   */
  colorReductionLevel(level) {
    this._actionModel.colorReductionLevel = level;
    this.colorReduction = level;
    return this;
  }
  prepareQualifiers() {
    this.addQualifier(new Qualifier("e", new QualifierValue([this.effectName, this.cartoonifyStrength, this.colorReduction])));
    return;
  }
  static fromJson(actionModel) {
    const { actionType, lineStrength, blackAndWhite, colorReductionLevel } = actionModel;
    const result = new this(actionType, lineStrength);
    blackAndWhite && result.blackwhite();
    colorReductionLevel && result.colorReductionLevel(colorReductionLevel);
    lineStrength && result.lineStrength(lineStrength);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Outline.js
var EffectOutline = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "outline";
  }
  /**
   * @description
   * How to apply the outline effect which can be one of the following values:
   * inner, inner_fill, outer, fill.
   * @param {OutlineModeType|string} mode  The type of outline effect. Use the constants defined in Outline.
   * @return {this}
   */
  mode(mode2) {
    this._actionModel.mode = mode2;
    this._mode = mode2;
    return this;
  }
  /**
   * The thickness of the outline in pixels. (Range: 1 to 100, Server default: 5)
   * @param {number} width
   * @return {this}
   */
  width(width) {
    this._actionModel.width = width;
    this._width = width;
    return this;
  }
  /**
   * @description
   * The level of blur of the outline.
   * Range: 0 to 2000, Server default: 0
   * @param {number | string} lvl
   * @return {this}
   */
  blurLevel(lvl) {
    this._actionModel.blurLevel = lvl;
    this._blurLevel = lvl;
    return this;
  }
  /**
   * @param {string | Qualifiers.Color} color One of the SDK Color values, string, or rgba: '#fff'
   * @return {this}
   */
  color(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", prepareColor(color2)));
  }
  prepareQualifiers() {
    this.addQualifier(new Qualifier("e", new QualifierValue(["outline", this._mode, this._width, this._blurLevel]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { actionType, mode: mode2, color: color2, blurLevel, width } = actionModel;
    const result = new this();
    mode2 && result.mode(mode2);
    color2 && result.color(color2);
    blurLevel && result.blurLevel(blurLevel);
    width && result.width(width);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/MakeTransparent.js
var MakeTransparentEffectAction = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "makeTransparent" };
  }
  /**
   * @description Sets the tolerance used to accommodate variance in the background color.
   * @param {number | string} value The tolerance used to accommodate variance in the background color. (Range: 0 to 100, Server default: 10)
   */
  tolerance(value) {
    this._actionModel.tolerance = value;
    const qualifierEffect = this.createEffectQualifier(this.effectType, value);
    this.addQualifier(qualifierEffect);
    return this;
  }
  /**
   * @description Sets the color to make transparent.
   * @param {string} color The HTML name of the color (red, green, etc.) or RGB hex code.
   * @return {this}
   */
  colorToReplace(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", new QualifierValue(prepareColor(color2))));
  }
  static fromJson(actionModel) {
    const { actionType, tolerance, color: color2 } = actionModel;
    const result = new this(ACTION_TYPE_TO_EFFECT_MODE_MAP[actionType], tolerance);
    tolerance && result.tolerance(tolerance);
    color2 && result.colorToReplace(color2);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Vectorize.js
var VectorizeEffectAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "vectorize";
  }
  /**
   * @description The number of colors. (Range: 2 to 30, Server default: 10)
   * @param {number | string} num
   * @return {this}
   */
  numOfColors(num) {
    this._actionModel.numOfColors = num;
    this._numOfColors = num;
    return this;
  }
  /**
   * @description The level of detail. Specify either a percentage of the original image (Range: 0.0 to 1.0) or an absolute number of pixels (Range: 0 to 1000). (Server default: 300)
   * @param {number | string} num
   * @return {this}
   */
  detailsLevel(num) {
    this._actionModel.detailLevel = num;
    this._detailsLevel = num;
    return this;
  }
  /**
   * @description The size of speckles to suppress. Specify either a percentage of the original image (Range: 0.0 to 1.0) or an absolute number of pixels (Range: 0 to 100, Server default: 2)
   * @param {number | string} num
   * @return {this}
   */
  despeckleLevel(num) {
    this._actionModel.despeckleLevel = num;
    this._despeckleLevel = num;
    return this;
  }
  /**
   * @description The corner threshold. Specify 100 for no smoothing (polygon corners), 0 for completely smooth corners. (Range: 0 to 100, Default: 25)
   * @param {number | string} num
   * @return {this}
   */
  cornersLevel(num) {
    this._actionModel.cornersLevel = num;
    this._cornersLevel = num;
    return this;
  }
  /**
   * @description The optimization value. Specify 100 for least optimization and the largest file. (Range: 0 to 100, Server default: 100).
   * @param {number} num
   * @return {this}
   */
  paths(num) {
    this._actionModel.paths = num;
    this._paths = num;
    return this;
  }
  prepareQualifiers() {
    let str = "vectorize";
    if (this._numOfColors) {
      str += `:${new QualifierValue(`colors:${this._numOfColors}`).toString()}`;
    }
    if (this._detailsLevel) {
      str += `:${new QualifierValue(`detail:${this._detailsLevel}`).toString()}`;
    }
    if (this._despeckleLevel) {
      str += `:${new QualifierValue(`despeckle:${this._despeckleLevel}`).toString()}`;
    }
    if (this._paths) {
      str += `:${new QualifierValue(`paths:${this._paths}`).toString()}`;
    }
    if (this._cornersLevel) {
      str += `:${new QualifierValue(`corners:${this._cornersLevel}`).toString()}`;
    }
    this.addQualifier(new Qualifier("e", str));
  }
  static fromJson(actionModel) {
    const { actionType, paths, cornersLevel, despeckleLevel, detailLevel, numOfColors } = actionModel;
    const result = new this();
    paths && result.paths(paths);
    cornersLevel && result.cornersLevel(cornersLevel);
    despeckleLevel && result.despeckleLevel(despeckleLevel);
    detailLevel && result.detailsLevel(detailLevel);
    numOfColors && result.numOfColors(numOfColors);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/SimulateColorBlind.js
var SimulateColorBlindEffectAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "simulateColorblind";
    this.addQualifier(new Qualifier("e", `simulate_colorblind`));
  }
  setQualifier(val) {
    const strToAppend = `:${val}`;
    if (val) {
      this.addQualifier(new Qualifier("e", `simulate_colorblind${strToAppend}`));
    }
    return this;
  }
  /**
   * @description Sets the color blind condition to simulate.
   * @param {Qualifiers.simulateColorBlindValues | SimulateColorBlindType | string} cond
   * @return {this}
   */
  condition(cond) {
    this._actionModel.condition = cond;
    return this.setQualifier(cond);
  }
  static fromJson(actionModel) {
    const { actionType, condition } = actionModel;
    const result = new this();
    condition && result.condition(condition);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/EffectActionWithLevel.js
var EffectActionWithLevel = class extends LeveledEffectAction {
  level(value) {
    this._actionModel.level = value;
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/AssistColorBlind.js
var AssistColorBlindEffectAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "assistColorblind";
    this.addQualifier(new Qualifier("e", new QualifierValue("assist_colorblind")));
  }
  /**
   * @description Replaces problematic colors with colors that are easier to differentiate.
   * @return {this}
   */
  xray() {
    this._actionModel.type = "xray";
    return this.addQualifier(new Qualifier("e", new QualifierValue(["assist_colorblind", "xray"]).setDelimiter(":")));
  }
  /**
   * @description Applies stripes of the specified intensity to help people with common color blind conditions to differentiate between colors that are similar for them.
   * @param {number | string} strength The intensity of the stripes. (Range: 1 to 100, Server default: 10)
   * @return {this}
   */
  stripesStrength(strength) {
    this._actionModel.type = "stripes";
    this._actionModel.stripesStrength = strength;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["assist_colorblind", strength]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { actionType, type, stripesStrength } = actionModel;
    const result = new this();
    if (type === "xray") {
      result.xray();
    }
    if (type === "stripes") {
      stripesStrength && result.stripesStrength(stripesStrength);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/GradientFade.js
var GradientFadeEffectAction = class extends Action {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "gradientFade" };
  }
  /**
   * @description Sets the strength of the fade effect.
   * @param {number} strength The strength of the fade effect. (Range: 0 to 100, Server default: 20)
   */
  strength(strength) {
    this._actionModel.strength = strength;
    this._strength = strength;
    return this;
  }
  /**
   * @description Sets the mode of gradient fade.
   * @param {string | Qualifiers.GradientFade} type The mode of gradient fade.
   */
  type(type) {
    this._actionModel.type = type;
    this._type = type;
    return this;
  }
  /**
   * @description Sets the x dimension of the start point.
   * @param {number | string} x The x dimension of the start point.
   */
  horizontalStartPoint(x) {
    this._actionModel.horizontalStartPoint = x;
    return this.addQualifier(new Qualifier("x", x));
  }
  /**
   * @description Sets the y dimension of the start point.
   * @param {number | string} y The y dimension of the start point.
   */
  verticalStartPoint(y) {
    this._actionModel.verticalStartPoint = y;
    return this.addQualifier(new Qualifier("y", y));
  }
  prepareQualifiers() {
    let str = "gradient_fade";
    if (this._type) {
      str += `:${this._type}`;
    }
    if (this._strength) {
      str += `:${this._strength}`;
    }
    this.addQualifier(new Qualifier("e", str));
  }
  static fromJson(actionModel) {
    const { actionType, verticalStartPoint, horizontalStartPoint, type, strength } = actionModel;
    const result = new this();
    verticalStartPoint && result.verticalStartPoint(verticalStartPoint);
    horizontalStartPoint && result.horizontalStartPoint(horizontalStartPoint);
    type && result.type(type);
    strength && result.strength(strength);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/FadeOut.js
var FadeOutEffectAction = class extends Action {
  constructor(duration) {
    super();
    this._actionModel = { actionType: "fadeOut" };
    this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `-${duration}`]).setDelimiter(":")));
    duration && (this._actionModel.length = duration);
  }
  /**
   *
   * @description Sets the duration level for the action
   * @param {string | number} duration - The duration of the effect
   */
  duration(duration) {
    this._actionModel.length = duration;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `-${duration}`]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { length } = actionModel;
    if (length === void 0) {
      return new this(1e3);
    }
    const result = new this(length);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Colorize.js
var ColorizeEffectAction = class extends EffectActionWithLevel {
  /**
   * @description The color to use for colorization. Specify HTML name or RGB hex code. (Server default: gray)
   * @param {string} color HTML name(red, green, etc.) or RGB hex code. (Server default: gray)
   * @return {this}
   */
  color(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", new QualifierValue(prepareColor(color2))));
  }
  static fromJson(actionModel) {
    const { actionType, level, color: color2 } = actionModel;
    const result = new this(actionType, level);
    color2 && result.color(color2);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Shadow.js
var ShadowEffectAction = class extends Action {
  constructor(effectType, strength) {
    super();
    this._actionModel = {};
    this._actionModel.actionType = effectType;
    this.effectType = effectType;
    this.addQualifier(new Qualifier("e", new QualifierValue(["shadow", strength])));
  }
  /**
   * @description The strength of the shadow. (Range: 0 to 100, Server default: 40)
   * @param {number} strength
   * @return {this}
   */
  strength(strength) {
    this._actionModel.strength = strength;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["shadow", strength])));
  }
  /**
   * @description The X offset the shadow
   * @param {number | SDK.ExpressionQualifier} x
   * @return {this}
   */
  offsetX(x) {
    this._actionModel.offsetX = x;
    return this.addQualifier(new Qualifier("x", new QualifierValue(x)));
  }
  /**
   * @description The Y offset the shadow
   * @param {number | SDK.ExpressionQualifier} y
   * @return {this}
   */
  offsetY(y) {
    this._actionModel.offsetY = y;
    return this.addQualifier(new Qualifier("y", new QualifierValue(y)));
  }
  /**
   * @description The color of the shadow (Server default: gray)
   * @param color
   * @return {this}
   */
  color(color2) {
    this._actionModel.color = color2;
    return this.addQualifier(new Qualifier("co", new QualifierValue(prepareColor(color2))));
  }
  static fromJson(actionModel) {
    const { actionType, strength, offsetX, offsetY, color: color2 } = actionModel;
    const result = new this(actionType, strength);
    offsetX && result.offsetX(offsetX);
    offsetY && result.offsetY(offsetY);
    color2 && result.color(color2);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/StyleTransfer.js
var StyleTransfer = class extends Action {
  /**
   * The Image Source used to create the style transfer,
   * Use the Image Source builder to quickly create a source:
   * </br>Import: {@link Qualifiers.Source|import Sources from '@cloudinary/url-gen/qualifiers/sources';}
   * </br>Create: `Source.image('dog')`
   * @param {ImageSource} imageSource
   */
  constructor(imageSource) {
    super();
    this.imageSource = imageSource;
  }
  /**
   * Determines the strength in which the styleTransfer is applied.
   * @param {number} [effectStrength] - The strength level, 1-100, default: 100
   * @return {this}
   */
  strength(effectStrength = null) {
    this.effectStrength = effectStrength;
    return this;
  }
  /**
   * More aggressively preserves the colors of the the target photo,
   * Can be used with `strength()` to enhance this behaviour
   * @param {boolean} bool
   * @return {this}
   */
  preserveColor(bool = true) {
    this.preserve = bool;
    return this;
  }
  /**
   * The `build` phase of the Action, used internally to concat all the options received into a single string.
   * The result of this method is the toString() of the imageLayer provided in the constructor.
   * @return {string}
   */
  toString() {
    const NAME = "style_transfer";
    const PRES = this.preserve ? "preserve_color" : null;
    const STRENGTH = this.effectStrength;
    const styleEffect = new Qualifier("e", new QualifierValue([NAME, PRES, STRENGTH]));
    const sourceOpenString = this.imageSource.getOpenSourceString("l");
    const imgTx = this.imageSource.getTransformation();
    const sourceTransformation = imgTx ? imgTx.toString() : "";
    return [
      sourceOpenString,
      sourceTransformation,
      `${styleEffect},fl_layer_apply`
    ].filter((a) => a).join("/");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Dither.js
var DitherEffectAction = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "dither" };
  }
  /**
   *
   * @param {Qualifiers.Dither} ditherType - The dither type applied to the image
   * @return {this}
   */
  type(ditherType) {
    this._actionModel.type = ditherType;
    const qualifierEffect = this.createEffectQualifier(this.effectType, ditherType);
    this.addQualifier(qualifierEffect);
    return this;
  }
  static fromJson(actionModel) {
    const { actionType, type } = actionModel;
    const result = new this(actionType);
    type && result.type(type);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Deshake.js
var DeshakeEffectAction = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this._actionModel = { actionType: "deshake" };
  }
  /**
   * The maximum number of pixels in the horizontal and vertical direction that will be addressed. (Possible values: 16, 32, 48, 64. Server default: 16)
   * @param value Possible values: 16, 32, 48, 64.  Server default: 16.
   */
  shakeStrength(value) {
    this._actionModel.pixels = value;
    const qualifierEffect = this.createEffectQualifier(this.effectType, value);
    this.addQualifier(qualifierEffect);
    return this;
  }
  static fromJson(actionModel) {
    const { actionType, pixels } = actionModel;
    const result = new this(actionType, pixels);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/pixelate/Pixelate.js
var Pixelate = class extends Action {
  constructor(squareSize) {
    super();
    this._actionModel = {};
    this._squareSize = squareSize;
    this._actionModel.actionType = "pixelate";
    this._actionModel.squareSize = squareSize;
  }
  /**
   * @description Specifies the region to piexlate.
   * @param {NamedRegion} pixelateRegion
   */
  region(pixelateRegion) {
    this._region = pixelateRegion;
    this._actionModel.region = { regionType: this._region.regionType };
    return this;
  }
  /**
   * @description Sets the squareSize of the pixelate effect.
   * @param {number | string} squareSize
   */
  squareSize(squareSize) {
    this._squareSize = squareSize;
    this._actionModel.squareSize = squareSize;
    return this;
  }
  prepareQualifiers() {
    const str = this._squareSize ? `:${this._squareSize}` : "";
    if ("_region" in this) {
      const qualifiers = this._region.qualifiers;
      qualifiers.forEach((q) => this.addQualifier(q));
      if (this._region.regionType === "custom") {
        this.addQualifier(new Qualifier("e", `pixelate_region${str}`));
      }
      if (this._region.regionType === "ocr_text") {
        this.addQualifier(new Qualifier("e", `pixelate_region${str}`));
        this.addQualifier(new Qualifier("g", `ocr_text`));
      }
      if (this._region.regionType === "faces") {
        this.addQualifier(new Qualifier("e", `pixelate_faces${str}`));
      }
    } else {
      this.addQualifier(new Qualifier("e", `pixelate${str}`));
    }
  }
  static fromJson(actionModel) {
    const { region, squareSize } = actionModel;
    const result = new this(squareSize);
    squareSize && result.squareSize(squareSize);
    if (region && region.regionType === "faces") {
      result.region(faces());
    }
    if (region && region.regionType === "custom") {
      result.region(custom());
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/EffectActionWithStrength.js
var EffectActionWithStrength = class extends LeveledEffectAction {
  constructor() {
    super(...arguments);
    this.LEVEL_NAME = "strength";
  }
  strength(value) {
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/Blackwhite.js
var BlackwhiteEffectAction = class extends LeveledEffectAction {
  threshold(value) {
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/leveled/FadeIn.js
var FadeInEffectAction = class extends Action {
  constructor(duration) {
    super();
    this._actionModel = { actionType: "fadeIn" };
    this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `${duration}`]).setDelimiter(":")));
    duration && (this._actionModel.length = duration);
  }
  /**
   *
   * @description Sets the duration level for the action
   * @param {string | number} duration - The duration of the effect
   */
  duration(duration) {
    this._actionModel.length = duration;
    return this.addQualifier(new Qualifier("e", new QualifierValue(["fade", `${duration}`]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { length } = actionModel;
    if (length === void 0) {
      return new this(1e3);
    }
    const result = new this(length);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/RemoveBackgroundAction.js
var RemoveBackgroundAction = class extends Action {
  constructor() {
    super();
    this.overwriteQualifier();
  }
  /**
   * @description Everytime this method is called, it will overwrite the e_bgremoval qualifier with new values
   * @private
   */
  overwriteQualifier() {
    const value = ["bgremoval", this._screen ? "screen" : "", (this._colorToRemove || "").replace("#", "")];
    return this.addQualifier(new Qualifier("e", new QualifierValue(value)));
  }
  /**
   * @description The strength of the shadow. (Range: 0 to 100, Server default: 40)
   * @param {number} useScreen Boolean, defaults to true
   * @return {this}
   */
  screen(useScreen = true) {
    this._screen = useScreen;
    return this.overwriteQualifier();
  }
  /**
   * @description The color to remove from the background
   * @param {SystemColors} color
   * @return {this}
   */
  colorToRemove(color2) {
    this._colorToRemove = color2;
    return this.overwriteQualifier();
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/Theme.js
var ThemeEffect = class extends Action {
  constructor(color2) {
    super();
    this.effectName = "theme";
    this.color = color2;
  }
  /**
   * @description The sensitivity to photographic elements of an image.
   *              A value of 0 treats the whole image as non-photographic.
   *              A value of 200 treats the whole image as photographic, so no theme change is applied.
   * @param {number} photosensitivity
   * @return {this}
   */
  photosensitivity(photosensitivity) {
    this._photosensitivity = photosensitivity;
    return this;
  }
  prepareQualifiers() {
    const sensitivity = this._photosensitivity ? `:photosensitivity_${this._photosensitivity}` : "";
    const val = `${this.effectName}:color_${this.color.replace("#", "")}${sensitivity}`;
    this.addQualifier(new Qualifier("e", new QualifierValue(val)));
    return;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/BackgroundRemoval.js
var BackgroundRemoval = class extends Action {
  constructor() {
    super();
    this._actionModel.actionType = "backgroundRemoval";
  }
  fineEdges(value = true) {
    this._fineEdges = value;
    this._actionModel.fineEdges = this._fineEdges;
    return this;
  }
  hints(...values) {
    if (values.length === 1 && Array.isArray(values[0])) {
      this._hints = values[0];
    } else if (values.length) {
      this._hints = values;
    }
    if (this._hints) {
      this._actionModel.hints = this._hints;
    }
    return this;
  }
  prepareQualifiers() {
    var _a;
    let str = "background_removal";
    const params = [];
    if (this._fineEdges !== void 0) {
      params.push(new QualifierValue(`fineedges_${this._fineEdges ? "y" : "n"}`).toString());
    }
    if ((_a = this._hints) === null || _a === void 0 ? void 0 : _a.length) {
      params.push(new QualifierValue(`hints_(${this._hints.join(";")})`).toString());
    }
    if (params.length > 0) {
      str += `:${params.join(";")}`;
    }
    this.addQualifier(new Qualifier("e", str));
  }
  static fromJson(actionModel) {
    const { fineEdges, hints } = actionModel;
    const result = new this();
    if (fineEdges !== void 0) {
      result.fineEdges(fineEdges);
    }
    if (hints === null || hints === void 0 ? void 0 : hints.length) {
      result.hints(hints);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/DropShadow.js
var DropShadow = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "dropshadow";
  }
  /**
   * @description
   * The direction the light is coming from to cause the shadow effect. (Range: 0 to 360, Server default: 215)
   * @param {number} azimuth
   * @return {this}
   */
  azimuth(azimuth) {
    this._actionModel.azimuth = azimuth;
    this._azimuth = azimuth;
    return this;
  }
  /**
   * @description
   * The height of the light source above the 'ground' to cause the shadow effect. (Range: 0 to 90, Server default: 45)
   * @param {number} elevation
   * @return {this}
   */
  elevation(elevation) {
    this._actionModel.elevation = elevation;
    this._elevation = elevation;
    return this;
  }
  /**
   * @description
   * The spread of the light source. A small number means 'point' light. A larger number means 'area' light. (Range: 0 to 100, Server default: 50)
   * @param {number} spread
   * @return {this}
   */
  spread(spread) {
    this._actionModel.spread = spread;
    this._spread = spread;
    return this;
  }
  prepareQualifiers() {
    const paramNames = ["azimuth", "elevation", "spread"];
    const paramValues = [this._azimuth, this._elevation, this._spread];
    const paramString = paramValues.map((value, index) => value !== void 0 ? `${paramNames[index]}_${value}` : "").filter(Boolean).join(";");
    this.addQualifier(new Qualifier("e", new QualifierValue(["dropshadow", paramString]).setDelimiter(":")));
  }
  static fromJson(actionModel) {
    const { azimuth, elevation, spread } = actionModel;
    const result = new this();
    azimuth && result.azimuth(azimuth);
    elevation && result.elevation(elevation);
    spread && result.spread(spread);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/GenerativeRemove.js
var GenerativeRemove = class extends Action {
  constructor() {
    super();
    this._prompts = [];
    this._regions = [];
    this._detectMultiple = false;
    this._removeShadow = false;
    this._actionModel.actionType = "generativeRemove";
  }
  prompt(...value) {
    this._prompts = value;
    if (this._prompts.length > 0) {
      this._actionModel.prompts = this._prompts;
    }
    return this;
  }
  region(...value) {
    this._regions = value;
    if (this._regions.length > 0) {
      this._actionModel.regions = this._regions.map((region) => region.toJson());
    }
    return this;
  }
  detectMultiple(value = true) {
    this._detectMultiple = value;
    if (this._detectMultiple) {
      this._actionModel.detectMultiple = this._detectMultiple;
    }
    return this;
  }
  removeShadow(value = true) {
    this._removeShadow = value;
    if (this._removeShadow) {
      this._actionModel.removeShadow = this._removeShadow;
    }
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue().setDelimiter(";");
    switch (true) {
      case this._prompts.length > 0: {
        qualifierValue.addValue(this.preparePromptValue());
        break;
      }
      case this._regions.length > 0: {
        qualifierValue.addValue(this.prepareRegionValue());
        break;
      }
    }
    if (this._detectMultiple) {
      qualifierValue.addValue("multiple_true");
    }
    if (this._removeShadow) {
      qualifierValue.addValue("remove-shadow_true");
    }
    this.addQualifier(new Qualifier("e", `gen_remove:${qualifierValue.toString()}`));
  }
  preparePromptValue() {
    const prompts = this._prompts;
    const qualifierValue = new QualifierValue().setDelimiter(";");
    if (prompts.length === 1) {
      qualifierValue.addValue(`prompt_${prompts[0]}`);
    } else {
      qualifierValue.addValue(`prompt_(${prompts.join(";")})`);
    }
    return qualifierValue;
  }
  prepareRegionValue() {
    const regions = this._regions;
    const qualifierValue = new QualifierValue();
    if (regions.length === 1) {
      const singleRegion = regions[0].toString();
      qualifierValue.addValue(`region_${singleRegion}`);
    } else {
      const regionList = regions.map((region) => region.toString());
      qualifierValue.addValue(`region_(${regionList.join(";")})`);
    }
    return qualifierValue;
  }
  static fromJson(actionModel) {
    const { prompts, regions, detectMultiple, removeShadow } = actionModel;
    const result = new this();
    if (regions) {
      result.region(...regions.map(({ x, y, width, height }) => new RectangleRegion(x, y, width, height)));
    }
    if (prompts) {
      result.prompt(...prompts);
    }
    if (detectMultiple) {
      result.detectMultiple(detectMultiple);
    }
    if (removeShadow) {
      result.removeShadow(removeShadow);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/GenerativeReplace.js
var GenerativeReplace = class extends Action {
  constructor() {
    super();
    this._preserveGeometry = false;
    this._detectMultiple = false;
    this._actionModel.actionType = "generativeReplace";
  }
  from(value) {
    this._from = value;
    this._actionModel.from = value;
    return this;
  }
  to(value) {
    this._to = value;
    this._actionModel.to = value;
    return this;
  }
  preserveGeometry(value = true) {
    this._preserveGeometry = value;
    if (value) {
      this._actionModel.preserveGeometry = true;
    }
    return this;
  }
  detectMultiple(value = true) {
    this._detectMultiple = value;
    if (this._detectMultiple) {
      this._actionModel.detectMultiple = this._detectMultiple;
    }
    return this;
  }
  prepareQualifiers() {
    let str = `gen_replace:from_${this._from};to_${this._to}`;
    if (this._preserveGeometry) {
      str += `;preserve-geometry_true`;
    }
    if (this._detectMultiple) {
      str += `;multiple_true`;
    }
    this.addQualifier(new Qualifier("e", str));
  }
  static fromJson(actionModel) {
    const { from, to, preserveGeometry, detectMultiple } = actionModel;
    const result = new this();
    result.from(from);
    result.to(to);
    if (preserveGeometry) {
      result.preserveGeometry();
    }
    if (detectMultiple) {
      result.detectMultiple();
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/GenerativeRecolor.js
var GenerativeRecolor = class extends Action {
  constructor(prompts, color2) {
    super();
    this._prompts = [];
    this._detectMultiple = false;
    this.multiple = this.detectMultiple.bind(this);
    this._prompts = Array.isArray(prompts) ? prompts : [prompts];
    this._toColor = color2;
    this._actionModel.actionType = "generativeRecolor";
    this._actionModel.prompts = this._prompts;
    this._actionModel.toColor = this._toColor;
  }
  detectMultiple(value = true) {
    this._detectMultiple = value;
    if (this._detectMultiple) {
      this._actionModel.detectMultiple = this._detectMultiple;
    }
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue().setDelimiter(";");
    if (this._prompts.length) {
      qualifierValue.addValue(this.preparePromptValue());
    }
    if (this._toColor) {
      const formattedColor = this._toColor.match(/^#/) ? this._toColor.substr(1) : this._toColor;
      qualifierValue.addValue(`to-color_${formattedColor}`);
    }
    if (this._detectMultiple) {
      qualifierValue.addValue("multiple_true");
    }
    this.addQualifier(new Qualifier("e", `gen_recolor:${qualifierValue.toString()}`));
  }
  preparePromptValue() {
    const prompts = this._prompts;
    const qualifierValue = new QualifierValue().setDelimiter(";");
    if (prompts.length === 1) {
      qualifierValue.addValue(`prompt_${prompts[0]}`);
    } else {
      qualifierValue.addValue(`prompt_(${prompts.join(";")})`);
    }
    return qualifierValue;
  }
  static fromJson(actionModel) {
    const { prompts, detectMultiple, toColor } = actionModel;
    const result = new this(prompts, toColor);
    if (detectMultiple) {
      result.detectMultiple(detectMultiple);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect.js
function blur(blurLevel) {
  return new BlurAction(blurLevel);
}
function grayscale() {
  return new SimpleEffectAction("grayscale");
}
function sepia(level) {
  return new EffectActionWithLevel("sepia", level);
}
function shadow(shadowLevel) {
  return new ShadowEffectAction("shadow", shadowLevel);
}
function colorize(colorizeLevel) {
  return new ColorizeEffectAction("colorize", colorizeLevel);
}
function oilPaint(oilPaintLevel) {
  return new EffectActionWithStrength("oil_paint", oilPaintLevel);
}
function artisticFilter(artisticFilterType) {
  return new SimpleEffectAction("art", artisticFilterType);
}
function cartoonify(cartoonifyLevel) {
  return new CartoonifyEffect("cartoonify", cartoonifyLevel);
}
function outline() {
  return new EffectOutline();
}
function styleTransfer(imageSource) {
  return new StyleTransfer(imageSource);
}
function boomerang() {
  return new SimpleEffectAction("boomerang");
}
function advancedRedEye() {
  return new SimpleEffectAction("adv_redeye");
}
function blackwhite(level) {
  return new BlackwhiteEffectAction("blackwhite", level);
}
function negate() {
  return new SimpleEffectAction("negate");
}
function redEye() {
  return new SimpleEffectAction("redeye");
}
function reverse() {
  return new SimpleEffectAction("reverse");
}
function accelerate(speedIncreasePercent) {
  return new AccelerationEffectAction(speedIncreasePercent);
}
function fadeIn(fadeLength) {
  return new FadeInEffectAction(fadeLength);
}
function fadeOut(fadeLength) {
  return new FadeOutEffectAction(fadeLength);
}
function loop(additionalLoops) {
  return new LoopEffectAction("loop", additionalLoops);
}
function makeTransparent(tolerance) {
  return new MakeTransparentEffectAction("make_transparent", tolerance);
}
function noise(percentage) {
  return new EffectActionWithLevel("noise", percentage);
}
function vignette(strength) {
  return new EffectActionWithStrength("vignette", strength);
}
function dither(ditherType) {
  return new DitherEffectAction("ordered_dither", ditherType);
}
function vectorize() {
  return new VectorizeEffectAction();
}
function gradientFade() {
  return new GradientFadeEffectAction();
}
function assistColorBlind() {
  return new AssistColorBlindEffectAction();
}
function simulateColorBlind() {
  return new SimulateColorBlindEffectAction();
}
function deshake(pixels) {
  return new DeshakeEffectAction("deshake", pixels);
}
function transition() {
  return new SimpleEffectAction("transition");
}
function pixelate(squareSize) {
  return new Pixelate(squareSize);
}
function removeBackground() {
  return new RemoveBackgroundAction();
}
function backgroundRemoval() {
  return new BackgroundRemoval();
}
function dropShadow() {
  return new DropShadow();
}
function generativeRemove() {
  return new GenerativeRemove();
}
function generativeReplace() {
  return new GenerativeReplace();
}
function generativeRecolor(prompts, color2) {
  return new GenerativeRecolor(prompts, color2);
}
function generativeRestore() {
  return new SimpleEffectAction("gen_restore");
}
function upscale() {
  return new SimpleEffectAction("upscale");
}
function theme(color2) {
  return new ThemeEffect(color2);
}
var Effect = {
  pixelate,
  deshake,
  boomerang,
  advancedRedEye,
  blackwhite,
  negate,
  redEye,
  reverse,
  accelerate,
  fadeIn,
  fadeOut,
  loop,
  makeTransparent,
  noise,
  vignette,
  blur,
  grayscale,
  sepia,
  shadow,
  colorize,
  oilPaint,
  artisticFilter,
  cartoonify,
  outline,
  styleTransfer,
  gradientFade,
  vectorize,
  assistColorBlind,
  simulateColorBlind,
  transition,
  dither,
  removeBackground,
  backgroundRemoval,
  dropShadow,
  generativeRemove,
  generativeReplace,
  generativeRecolor,
  generativeRestore,
  upscale,
  theme
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/rotate/RotateAction.js
var QUALIFIER_KEY = "a";
var RotateAction = class extends Action {
  constructor(angle) {
    super();
    this._actionModel = {};
    this.addQualifier(new Qualifier(QUALIFIER_KEY, angle));
    this._actionModel.actionType = "rotateByAngle";
    if (angle) {
      this._actionModel.angle = angle;
    }
  }
  /**
   * @description Rotates an asset using a defined mode.
   * @param {Qualifiers.RotationMode | RotationModeType | string} rotationMode
   * For a list of supported rotation modes see {@link Qualifiers.RotationMode| types of rotation modes} for
   * possible values
   * @return {this}
   */
  mode(rotationMode) {
    return this.addValueToQualifier(QUALIFIER_KEY, rotationMode);
  }
  /**
   * @description Rotates an asset by the specified degrees.
   * @param {number} degrees rotation in degrees e.g 90, 45, 33
   * @return {this}
   */
  angle(degrees) {
    this._actionModel.angle = degrees;
    return this.addValueToQualifier(QUALIFIER_KEY, degrees);
  }
  static fromJson(actionModel) {
    const { angle } = actionModel;
    const result = new this(angle);
    return result;
  }
};
var RotateAction_default = RotateAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/rotate.js
function mode(rotationMode) {
  return new RotateAction_default().mode(rotationMode);
}
function byAngle(angle) {
  return new RotateAction_default(angle);
}
var Rotate = { byAngle, mode };

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/FillLightAction.js
var FillLightAction = class extends Action {
  constructor() {
    super();
  }
  /**
   * @description Sets the level of adjustment
   * @param {number} lvl How much to blend the adjusted fill light, where 0 means only use the original and 100 means only use the adjusted fill light result. (Range: 0 to 100, Server default: 100)
   */
  blend(blend) {
    this.lvl = blend;
    return this;
  }
  /**
   * @description Sets the level of the bias
   * @param {number} biasLvl The bias to apply to the fill light effect (Range: -100 to 100, Server default: 0).
   */
  bias(biasLvl) {
    this.biasLvl = biasLvl;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue(["fill_light", this.lvl, this.biasLvl]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/RecolorAction.js
var RecolorAction = class extends Action {
  constructor(recolorMatrix) {
    super();
    this.matrix = recolorMatrix;
    const flat = [];
    for (let row = 0; row < recolorMatrix.length; row++) {
      for (let col = 0; col < recolorMatrix[row].length; col++) {
        flat.push(recolorMatrix[row][col].toString());
      }
    }
    const qualifierValue = new QualifierValue(["recolor", ...flat]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/OpacityAdjustAction.js
var OpacityAdjustAction = class extends Action {
  constructor(level) {
    super();
    this._actionModel = { actionType: "opacity" };
    this.level = level;
    this._actionModel.level = level;
    this.addQualifier(new Qualifier("o", level));
  }
  static fromJson(actionModel) {
    const { level } = actionModel;
    return new this(level);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/By3dLutAction.js
var By3dLutAction = class extends Action {
  constructor(publicId) {
    super();
    this.publicId = publicId;
  }
  /**
   * Returns a string representation of the action
   * @return {string}
   */
  toString() {
    return `l_lut:${this.publicId}/fl_layer_apply`;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/ImproveAction.js
var ImproveAction = class extends Action {
  constructor() {
    super();
    this._actionModel = { actionType: "improve" };
  }
  /**
   *
   * @description The improve mode.
   * @param {Qualifiers.ImproveMode | string} value
   */
  mode(value) {
    this.modeValue = value;
    this._actionModel.mode = value;
    return this;
  }
  /**
   * @description How much to blend the improved result with the original image, where 0 means only use the original and 100 means only use the improved result. (Range: 0 to 100, Server default: 100)
   * @param {number} value
   */
  blend(value) {
    this.blendValue = value;
    this._actionModel.blend = value;
    return this;
  }
  prepareQualifiers() {
    const qualifierValue = new QualifierValue(["improve", this.modeValue, this.blendValue]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
  static fromJson(actionModel) {
    const { mode: mode2, blend } = actionModel;
    const result = new this();
    mode2 && result.mode(mode2);
    blend && result.blend(blend);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/ReplaceColorAction.js
var ReplaceColorAction = class extends Action {
  /**
   * @description Sets the target output color.
   * @param {string} toColor - The HTML name or RGB/A hex code of the target output color.
   */
  constructor(toColor) {
    super();
    this.targetColor = toColor;
  }
  /**
   * @description Sets the tolerance threshold.
   * @param {number} toleranceLevel - The tolerance threshold (a radius in the LAB color space) from the input color, </br>
   *                                  representing the span of colors that should be replaced with a correspondingly adjusted version of the target output color. </br>
   *                                  Larger values result in replacing more colors within the image. </br>
   *                                  The more saturated the original input color, the more a change in value will impact the result (Server default: 50).
   * @return {this}
   */
  tolerance(toleranceLevel) {
    this.toleranceLevel = toleranceLevel;
    return this;
  }
  /**
   * @description Sets the base input color to map.
   * @param {string} baseColor - The HTML name or RGB/A hex code of the base input color to map (Server default: the most prominent high-saturation color in the image).
   * @return {this}
   */
  fromColor(baseColor) {
    this.baseColor = baseColor;
    return this;
  }
  prepareQualifiers() {
    const targetColor = this.targetColor && this.targetColor.toString().replace("#", "");
    const baseColor = this.baseColor && this.baseColor.toString().replace("#", "");
    const qualifierValue = new QualifierValue(["replace_color", targetColor, this.toleranceLevel, baseColor]);
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/effect/EffectActions/EffectActionWithBlend.js
var EffectActionWithBlend = class extends LeveledEffectAction {
  blend(value) {
    return this.setLevel(value);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust/simple/ViesusCorrectAdjustAction.js
var ViesusCorrectAdjustAction = class extends Action {
  /**
   * @description Enhances the image without correcting for red eye.
   */
  noRedEye() {
    this._noRedEye = true;
    return this;
  }
  /**
   * @description Applies saturation to the skin tones in the image.
   * @param level The saturation level. (Range: -100 to 100, Server default: 50).
   */
  skinSaturation(level) {
    this._skinSaturation = true;
    if (level) {
      this._skinSaturationLevel = level;
    }
    return this;
  }
  prepareQualifiers() {
    let value = "viesus_correct";
    if (this._noRedEye) {
      value += ":no_redeye";
    }
    if (this._skinSaturation) {
      value += ":skin_saturation";
      if (typeof this._skinSaturationLevel !== "undefined") {
        value += `_${this._skinSaturationLevel}`;
      }
    }
    this.addQualifier(new Qualifier("e", value));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/adjust.js
function tint(value = "") {
  return new SimpleEffectAction("tint", value);
}
function brightness(level) {
  return new EffectActionWithLevel("brightness", level);
}
function viesusCorrect() {
  return new ViesusCorrectAdjustAction();
}
function red(level) {
  return new EffectActionWithLevel("red", level);
}
function sharpen(strength) {
  return new EffectActionWithStrength("sharpen", strength);
}
function saturation(level) {
  return new EffectActionWithLevel("saturation", level);
}
function contrast(level) {
  return new EffectActionWithLevel("contrast", level);
}
function gamma(level) {
  return new EffectActionWithLevel("gamma", level);
}
function blue(level) {
  return new EffectActionWithLevel("blue", level);
}
function brightnessHSB(level) {
  return new EffectActionWithLevel("brightness_hsb", level);
}
function opacityThreshold(level) {
  return new EffectActionWithLevel("opacity_threshold", level);
}
function autoColor(blend) {
  return new EffectActionWithBlend("auto_color", blend);
}
function autoBrightness(blend) {
  return new EffectActionWithBlend("auto_brightness", blend);
}
function hue(level) {
  return new EffectActionWithLevel("hue", level);
}
function green(level) {
  return new EffectActionWithLevel("green", level);
}
function unsharpMask(strength) {
  return new EffectActionWithStrength("unsharp_mask", strength);
}
function vibrance(strength) {
  return new EffectActionWithStrength("vibrance", strength);
}
function autoContrast(blend) {
  return new EffectActionWithBlend("auto_contrast", blend);
}
function opacity(level) {
  return new OpacityAdjustAction(level);
}
function improve() {
  return new ImproveAction();
}
function replaceColor(toColor) {
  return new ReplaceColorAction(toColor);
}
function recolor(matrix) {
  return new RecolorAction(matrix);
}
function fillLight() {
  return new FillLightAction();
}
function by3dLut(publicId) {
  return new By3dLutAction(publicId);
}
var Adjust = {
  brightness,
  viesusCorrect,
  opacity,
  red,
  sharpen,
  improve,
  saturation,
  contrast,
  gamma,
  green,
  blue,
  brightnessHSB,
  hue,
  autoBrightness,
  autoColor,
  autoContrast,
  vibrance,
  unsharpMask,
  opacityThreshold,
  replaceColor,
  recolor,
  fillLight,
  by3dLut,
  tint
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/blendMode/BlendModeQualifier.js
var BlendModeQualifier = class extends Action {
  constructor(blendMode, level) {
    super();
    this.addQualifier(new Qualifier("e", new QualifierValue([blendMode, level])));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/IImageSourceModel.js
function isIImageSourceModel(obj) {
  return obj && obj.sourceType === "image";
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/IFetchSourceModel.js
function isIFetchSourceModel(obj) {
  return obj && obj.sourceType === "fetch";
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/ITextSourceModel.js
function isITextSourceModel(obj) {
  return obj && obj.sourceType === "text";
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createSourceFromModel.js
function createSourceFromModel(source3, transformationFromJson) {
  if (isITextSourceModel(source3)) {
    return TextSource.fromJson(source3, transformationFromJson);
  } else if (isIImageSourceModel(source3)) {
    return ImageSource.fromJson(source3, transformationFromJson);
  } else if (isIFetchSourceModel(source3)) {
    return FetchSource.fromJson(source3, transformationFromJson);
  } else {
    return VideoSource.fromJson(source3, transformationFromJson);
  }
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createPositionFromModel.js
function createPositionFromModel(position) {
  const { offsetX, offsetY, tiled: tiled2, allowOverflow, gravity } = position;
  const result = new PositionQualifier();
  if (offsetX) {
    result.offsetX(offsetX);
  }
  if (offsetY) {
    result.offsetY(offsetY);
  }
  if (tiled2) {
    result.tiled();
  }
  if (allowOverflow != null) {
    result.allowOverflow(allowOverflow);
  }
  if (gravity) {
    result.gravity(createGravityFromModel(gravity));
  }
  return result;
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/video/TimelinePosition.js
var TimelinePosition = class extends Action {
  constructor() {
    super();
    this._actionModel = {};
  }
  /**
   * @param {string | number} startOffset
   */
  startOffset(startOffset) {
    const startOffsetQualifier = new Qualifier("so", startOffset);
    this.addQualifier(startOffsetQualifier);
    this._actionModel.startOffset = startOffsetQualifier.qualifierValue.toString();
    return this;
  }
  /**
   * @param {string | number} endOffset
   */
  endOffset(endOffset) {
    const endOffsetQualifier = new Qualifier("eo", endOffset);
    this.addQualifier(endOffsetQualifier);
    this._actionModel.endOffset = endOffsetQualifier.qualifierValue.toString();
    return this;
  }
  /**
   * @param {string | number} duration
   */
  duration(duration) {
    const durationQualifier = new Qualifier("du", duration);
    this.addQualifier(durationQualifier);
    this._actionModel.duration = durationQualifier.qualifierValue.toString();
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createTimelinePositionFromModel.js
function createTimelinePositionFromModel(timelinePosition) {
  const { startOffset, endOffset, duration } = timelinePosition;
  const result = new TimelinePosition();
  if (startOffset) {
    result.startOffset(startOffset);
  }
  if (endOffset) {
    result.endOffset(endOffset);
  }
  if (duration) {
    result.duration(duration);
  }
  return result;
}

// node_modules/@cloudinary/transformation-builder-sdk/actions/layer/LayerAction.js
var LayerAction = class extends Action {
  /**
   * @description Creates a LayerAction to be used with overlays and underlays
   * @param {ImageSource | TextSource | VideoSource} layerSource The Source used for the layer, use the builders provided {@link Qualifiers.Source|here}
   */
  constructor(layerSource) {
    super();
    this.source = layerSource;
    this._actionModel = {
      actionType: "overlay",
      source: layerSource.toJson()
    };
  }
  /**
   * @description Sets the layerType to 'u' (underlay) or 'l' (overlay).
   * @param {'u' | 'l'} type
   * @return {this}
   */
  setLayerType(type) {
    this.layerType = type;
    this._actionModel.actionType = type === "u" ? "underlay" : "overlay";
    return this;
  }
  /**
   * @description Sets the timeline position of the video layer
   * @param {Qualifiers.TimelinePosition} timelinePosition
   * @return {this}
   */
  timeline(timelinePosition) {
    this._timelinePosition = timelinePosition;
    this._actionModel.timelinePosition = timelinePosition.toJson();
    return this;
  }
  /**
   * @description Sets the position of the layer
   * @param {Qualifiers.Position} position
   * @return {this}
   */
  position(position) {
    this._position = position;
    this._actionModel.position = position.toJson();
    return this;
  }
  /**
   * @description Specifies how to blend the image overlay with the base overlay
   * @param {Qualifiers.BlendMode|BlendModeType} blendMode
   * @return {this}
   */
  blendMode(blendMode) {
    this._blendMode = blendMode;
    const [mode2, level] = `${blendMode}`.replace("e_", "").split(":");
    if (mode2 === "anti_removal") {
      this._actionModel.blendMode = level ? { blendModeType: "antiRemoval", level } : { blendModeType: "antiRemoval" };
    } else {
      this._actionModel.blendMode = { blendModeType: mode2 };
    }
    return this;
  }
  /**
   * @private
   * @description
   * Closes a layer (layers are built in three stages -> /Open/Transform/Close).
   * @return {SDK.Action}
   */
  closeLayer() {
    var _a, _b, _c, _d;
    const bit = new Action().addFlag(new FlagQualifier("layer_apply"));
    (_a = this._position) === null || _a === void 0 ? void 0 : _a.qualifiers.forEach((qualifier) => {
      bit.addQualifier(qualifier);
    });
    (_b = this._position) === null || _b === void 0 ? void 0 : _b.flags.forEach((flag) => {
      bit.addFlag(flag);
    });
    if (typeof this._blendMode === "string") {
      bit.addQualifier(new Qualifier("e", this._blendMode));
    } else {
      (_c = this._blendMode) === null || _c === void 0 ? void 0 : _c.qualifiers.forEach((qualifier) => {
        bit.addQualifier(qualifier);
      });
    }
    (_d = this._timelinePosition) === null || _d === void 0 ? void 0 : _d.qualifiers.forEach((qualifier) => {
      bit.addQualifier(qualifier);
    });
    return bit;
  }
  /**
   * @private
   * @description
   * Opens a layer (layers are built in three stages -> /Open/Transform/Close).
   * @return string
   */
  openLayer() {
    return `${this.source.getOpenSourceString(this.layerType)}`;
  }
  /**
   * @description
   * Serializes the Layer to a string
   * @return {string}
   */
  toString() {
    return [
      this.openLayer(),
      this.source.getTransformation() && this.source.getTransformation().toString(),
      this.closeLayer()
    ].filter((a) => a).join("/");
  }
  static fromJson(actionModel, transformationFromJson) {
    const { source: source3, actionType, position, timelinePosition, blendMode } = actionModel;
    const sourceInstance = createSourceFromModel(source3, transformationFromJson);
    const result = new this(sourceInstance);
    const layerType = actionType === "overlay" ? "l" : "u";
    result.setLayerType(layerType);
    if (position) {
      result.position(createPositionFromModel(position));
    }
    if (timelinePosition) {
      result.timeline(createTimelinePositionFromModel(timelinePosition));
    }
    if (blendMode) {
      const blendModeType = ACTION_TYPE_TO_BLEND_MODE_MAP[blendMode.blendModeType] || blendMode.blendModeType;
      if (blendMode === null || blendMode === void 0 ? void 0 : blendMode.level) {
        result.blendMode(new BlendModeQualifier(blendModeType, blendMode.level));
      } else {
        result.blendMode(new BlendModeQualifier(blendModeType));
      }
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/overlay.js
function source(source3) {
  return new LayerAction(source3).setLayerType("l");
}
var Overlay = { source };

// node_modules/@cloudinary/transformation-builder-sdk/actions/underlay.js
function source2(source3) {
  return new LayerAction(source3).setLayerType("u");
}
var Underlay = { source: source2 };

// node_modules/@cloudinary/transformation-builder-sdk/actions/namedTransformation/NamedTransformationAction.js
var NamedTransformationAction = class extends Action {
  /**
   *
   * @param {string} name The name of the named transformation
   */
  constructor(name2) {
    super();
    this.addQualifier(new Qualifier("t", name2));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/namedTransformation.js
function name(name2) {
  return new NamedTransformationAction(name2);
}
var NamedTransformation = { name };

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryAction.js
var DeliveryAction = class extends Action {
  /**
   * @param {string} deliveryKey A generic Delivery Action Key (such as q, f, dn, etc.)
   * @param {string} deliveryType A Format Qualifiers for the action, such as Quality.auto()
   * @param {string} modelProperty internal model property of the action, for example quality uses `level` while dpr uses `density`
   * @see Visit {@link Actions.Delivery|Delivery} for an example
   */
  constructor(deliveryKey, deliveryType, modelProperty) {
    super();
    this._actionModel = {};
    let deliveryTypeValue;
    if (deliveryType instanceof FormatQualifier) {
      deliveryTypeValue = deliveryType.getValue();
    } else {
      deliveryTypeValue = deliveryType;
    }
    this._actionModel.actionType = DELIVERY_MODE_TO_ACTION_TYPE_MAP[deliveryKey];
    this._actionModel[modelProperty] = deliveryTypeValue;
    this.addQualifier(new Qualifier(deliveryKey, deliveryType));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/progressive.js
var ProgressiveQualifier = class extends FlagQualifier {
  constructor(mode2) {
    super("progressive", mode2);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryFormatAction.js
var DeliveryFormatAction = class extends DeliveryAction {
  constructor(deliveryKey, deliveryType) {
    super(deliveryKey, deliveryType, "formatType");
  }
  /**
   * @description Uses lossy compression when delivering animated GIF files.
   * @return {this}
   */
  lossy() {
    this._actionModel.lossy = true;
    this.addFlag(lossy());
    return this;
  }
  /**
   * @description Uses progressive compression when delivering JPG file format.
   * @return {this}
   */
  progressive(mode2) {
    if (mode2 instanceof ProgressiveQualifier) {
      this._actionModel.progressive = { mode: mode2.getFlagValue() };
      this.addFlag(mode2);
    } else {
      this._actionModel.progressive = { mode: mode2 };
      this.addFlag(progressive(mode2));
    }
    return this;
  }
  /**
   * @description Ensures that images with a transparency channel are delivered in PNG format.
   */
  preserveTransparency() {
    this._actionModel.preserveTransparency = true;
    this.addFlag(preserveTransparency());
    return this;
  }
  static fromJson(actionModel) {
    const { formatType, lossy: lossy2, progressive: progressive2, preserveTransparency: preserveTransparency2 } = actionModel;
    let result;
    if (formatType) {
      result = new this("f", formatType);
    } else {
      result = new this("f");
    }
    if (progressive2) {
      if (progressive2.mode) {
        result.progressive(progressive2.mode);
      } else {
        result.progressive();
      }
    }
    lossy2 && result.lossy();
    preserveTransparency2 && result.preserveTransparency();
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryQualityAction.js
var DeliveryQualityAction = class extends DeliveryAction {
  /**
   * @param {Qualifiers.Quality} qualityValue a Quality value
   */
  constructor(qualityValue) {
    super("q", qualityValue.toString(), "level");
  }
  /**
   * Selet the Chroma sub sampling</br>
   * <b>Learn more</b>: {@link https://cloudinary.com/documentation/image_optimization#toggle_chroma_subsampling|Toggling chroma subsampling}
   * @param {420 | 444 | number} type The chroma sub sampling type
   */
  chromaSubSampling(type) {
    this._actionModel.chromaSubSampling = CHROMA_VALUE_TO_CHROMA_MODEL_ENUM[type];
    const qualityWithSubSampling = new QualifierValue([this._actionModel.level, type]);
    qualityWithSubSampling.setDelimiter(":");
    return this.addQualifier(new Qualifier("q", qualityWithSubSampling));
  }
  /**
   * Controls the final quality by setting a maximum quantization percentage
   * @param {number} val
   */
  quantization(val) {
    this._actionModel.quantization = val;
    const qualityWithQuantization = new QualifierValue([this._actionModel.level, `qmax_${val}`]).setDelimiter(":");
    return this.addQualifier(new Qualifier("q", qualityWithQuantization));
  }
  static fromJson(actionModel) {
    const { level, chromaSubSampling, quantization } = actionModel;
    const levelType = ACTION_TYPE_TO_QUALITY_MODE_MAP[level] || level;
    const result = new this(levelType);
    if (chromaSubSampling) {
      const chromaValue = CHROMA_MODEL_ENUM_TO_CHROMA_VALUE[chromaSubSampling.toUpperCase()];
      chromaValue && result.chromaSubSampling(+chromaValue);
    }
    quantization && result.quantization(quantization);
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryColorSpaceFromICCAction.js
var DeliveryColorSpaceFromICCAction = class extends Action {
  /**
   * @param {string} publicId
   */
  constructor(publicId) {
    super();
    this._actionModel = {};
    this._actionModel.actionType = "colorSpaceFromICC";
    this._actionModel.publicId = publicId;
    const qualifierValue = new QualifierValue(["icc", publicId]).setDelimiter(":");
    this.addQualifier(new Qualifier("cs", qualifierValue));
  }
  static fromJson(actionModel) {
    const { publicId } = actionModel;
    return new this(publicId);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryColorSpaceAction.js
var DeliveryColorSpaceAction = class extends Action {
  /**
   * Create a new DeliveryColorSpaceAction
   * @param mode
   */
  constructor(mode2) {
    super();
    this._actionModel = {};
    this._actionModel = {
      actionType: "colorSpace",
      mode: COLOR_SPACE_MODE_TO_COLOR_SPACE_MODEL_MODE_MAP[mode2] || mode2
    };
    this.addQualifier(new Qualifier("cs", ColorSpace[mode2] ? ColorSpace[mode2]() : mode2));
  }
  static fromJson(actionModel) {
    const { mode: mode2 } = actionModel;
    const colorSpaceMode = COLOR_SPACE_MODEL_MODE_TO_COLOR_SPACE_MODE_MAP[mode2] || mode2;
    return new this(colorSpaceMode);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery/DeliveryDPRAction.js
var DeliveryDPRAction = class extends Action {
  /**
   * Create a new DeliveryDPRAction
   * @param dprValue
   */
  constructor(dprValue) {
    super();
    this._actionModel = { actionType: "dpr" };
    const dprAsFloat = toFloatAsString(dprValue);
    this._actionModel.dpr = dprAsFloat;
    this.addQualifier(new Qualifier("dpr", dprAsFloat));
  }
  static fromJson(actionModel) {
    const { dpr: dpr2 } = actionModel;
    return new this(dpr2);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/delivery.js
function format(format2) {
  return new DeliveryFormatAction("f", format2);
}
function dpr(dpr2) {
  return new DeliveryDPRAction(dpr2);
}
function quality(qualityType) {
  return new DeliveryQualityAction(qualityType);
}
function density(value) {
  return new DeliveryAction("dn", value, "density");
}
function defaultImage(publicIdWithExtension) {
  return new DeliveryAction("d", publicIdWithExtension, "defaultImage");
}
function colorSpace(mode2) {
  return new DeliveryColorSpaceAction(mode2);
}
function colorSpaceFromICC(publicId) {
  return new DeliveryColorSpaceFromICCAction(publicId);
}
var Delivery = {
  format,
  dpr,
  density,
  defaultImage,
  colorSpace,
  colorSpaceFromICC,
  quality
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/customFunction/CustomFunctionAction.js
var CustomFunctionAction = class extends Action {
  /**
   *
   * @param {string} fn The custom function to use, can be a URL or a publicID
   */
  constructor(fn) {
    super();
    this.fn = fn;
  }
  encodeCustomFunctionString(fn) {
    const encodedSource = base64Encode(fn);
    return encodedSource;
  }
  /**
   * Use a WASM as a custom function,
   * Used with the builders of `remote` and `wasm` from {@link Actions.CustomFunction|Custom functions}
   */
  asWasm() {
    this.mode = "wasm";
    return this;
  }
  /**
   * Use a remote URL as a custom function
   * Used with the builders of `remote` and `wasm` from {@link Actions.CustomFunction|Custom functions}
   */
  asRemote() {
    this.mode = "remote";
    return this;
  }
  prepareQualifiers() {
    this.encodedFn = this.fn;
    if (this.mode === "remote") {
      this.encodedFn = this.encodeCustomFunctionString(this.fn);
    }
    return this.addQualifier(new Qualifier("fn", new QualifierValue([this.pre, this.mode, this.encodedFn])));
  }
  toString() {
    return super.toString().replace(/\//g, ":");
  }
};
var CustomFunctionAction_default = CustomFunctionAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/customFunction/RemoteAction.js
var RemoteAction = class extends CustomFunctionAction_default {
  constructor(fn) {
    super(fn);
  }
  preprocess() {
    this.pre = "pre";
    return this;
  }
};
var RemoteAction_default = RemoteAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/customFunction.js
function remote(path) {
  return new RemoteAction_default(path).asRemote();
}
function wasm(publicID) {
  return new CustomFunctionAction_default(publicID).asWasm();
}
var CustomFunction = { remote, wasm };

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/TrimAction.js
var TrimAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {
      actionType: "trimVideo"
    };
  }
  /**
   *
   * @description Support Percentages in values (30% -> 30p)
   * @param {string|number} val
   * @private
   * @return {string}
   */
  parseVal(val) {
    return typeof val === "number" ? val : val.replace("%", "p");
  }
  /**
   * @description Sets the starting position of the part of the video to keep when trimming videos.
   *
   * @param {string|number} offset The starting position of the part of the video to keep. This can be specified as a
   *                           float representing the time in seconds or a string representing the percentage of the
   *                           video length (for example, "30%" or "30p").
   * @return {this}
   */
  startOffset(offset) {
    this._actionModel.startOffset = +offset;
    return this.addQualifier(new Qualifier("so", this.parseVal(offset)));
  }
  /**
   * @description Sets the end position of the part of the video to keep when trimming videos.
   *
   * @param {string|number} offset The end position of the part of the video to keep. This can be specified as a
   *                         float representing the time in seconds or a string representing the percentage of the
   *                         video length (for example, "30%" or "30p").
   * @return {this}
   */
  endOffset(offset) {
    this._actionModel.endOffset = +offset;
    return this.addQualifier(new Qualifier("eo", this.parseVal(offset)));
  }
  /**
   * @description Sets the duration of the video to keep.
   *
   * @param {string|number} duration The length of the part of the video to keep. This can be specified as a float
   *                        representing the time in seconds or a string representing the percentage of the
   *                        video length (for example, "30%" or "30p").
   * @return {this}
   */
  duration(duration) {
    this._actionModel.duration = duration;
    return this.addQualifier(new Qualifier("du", this.parseVal(duration)));
  }
  static fromJson(actionModel) {
    const { duration, startOffset, endOffset } = actionModel;
    const result = new this();
    if (duration != null) {
      result.duration(duration);
    }
    if (startOffset != null) {
      result.startOffset(startOffset);
    }
    if (endOffset != null) {
      result.endOffset(endOffset);
    }
    return result;
  }
};
var TrimAction_default = TrimAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/background/actions/BackgroundColor.js
var BackgroundColor = class extends Action {
  constructor(color2) {
    super();
    this.addQualifier(new Qualifier("b", new QualifierValue(color2).setDelimiter("_")));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/RawAction.js
var RawAction = class {
  constructor(raw) {
    this.raw = raw;
  }
  toString() {
    return this.raw;
  }
  toJson() {
    return { error: createUnsupportedError(`unsupported action ${this.constructor.name}`) };
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/IErrorObject.js
function isErrorObject(obj) {
  const errorObj = obj;
  return "error" in errorObj && !!errorObj.error;
}

// node_modules/@cloudinary/transformation-builder-sdk/transformation/Transformation.js
var Transformation = class _Transformation {
  constructor() {
    this.actions = [];
  }
  /**
   * @param {SDK.Action | string} action
   * @return {this}
   */
  addAction(action) {
    let actionToAdd;
    if (typeof action === "string") {
      if (action.indexOf("/") >= 0) {
        throw "addAction cannot accept a string with a forward slash in it - /, use .addTransformation() instead";
      } else {
        actionToAdd = new RawAction(action);
      }
    } else {
      actionToAdd = action;
    }
    this.actions.push(actionToAdd);
    return this;
  }
  /**
   * @description Allows the injection of a raw transformation as a string into the transformation, or a Transformation instance that was previously created
   * @param {string | SDK.Transformation} tx
   * @example
   * import {Transformation} from "@cloudinary/url-gen";
   *
   * const transformation = new Transformation();
   * transformation.addTransformation('w_100/w_200/w_300');
   * @return {this}
   */
  addTransformation(tx) {
    if (tx instanceof _Transformation) {
      this.actions = this.actions.concat(tx.actions);
    } else {
      this.actions.push(new RawAction(tx));
    }
    return this;
  }
  /**
   * @return {string}
   */
  toString() {
    return this.actions.map((action) => {
      return action.toString();
    }).filter((a) => a).join("/");
  }
  /**
   * @description Delivers an animated GIF.
   * @param {AnimatedAction} animatedAction
   * @return {this}
   */
  animated(animatedAction) {
    return this.addAction(animatedAction);
  }
  /**
   * @description Adds a border around the image.
   * @param {Border} borderAction
   * @return {this}
   */
  border(borderAction) {
    return this.addAction(borderAction);
  }
  /**
   * @description Adjusts the shape of the delivered image. </br>
   * <b>Learn more:</b> {@link https://cloudinary.com/documentation/effects_and_artistic_enhancements#distort|Shape changes and distortion effects}
   * @param {IReshape} reshapeAction
   * @return {this}
   */
  reshape(reshapeAction) {
    return this.addAction(reshapeAction);
  }
  /**
   * @description Resize the asset using provided resize action
   * @param {ResizeSimpleAction} resizeAction
   * @return {this}
   */
  resize(resizeAction) {
    return this.addAction(resizeAction);
  }
  /**
   * @desc An alias to Action Delivery.quality
   * @param {string|number} quality
   * @return {this}
   */
  quality(quality2) {
    this.addAction(new DeliveryFormatAction("q", quality2));
    return this;
  }
  /**
   * @desc An alias to Action Delivery.format
   * @param {string} format
   * @return {this}
   */
  format(format2) {
    this.addAction(new DeliveryFormatAction("f", format2));
    return this;
  }
  /**
   * @description Rounds the specified corners of an image.
   * @param roundCornersAction
   * @return {this}
   */
  roundCorners(roundCornersAction) {
    return this.addAction(roundCornersAction);
  }
  /**
   * @description Adds an overlay over the base image.
   * @param {LayerAction} overlayAction
   * @return {this}
   */
  overlay(overlayAction) {
    return this.addAction(overlayAction);
  }
  /**
   * @description Adds an underlay under the base image.
   * @param {LayerAction} underlayAction
   * @return {this}
   */
  underlay(underlayAction) {
    underlayAction.setLayerType("u");
    return this.addAction(underlayAction);
  }
  /**
   * @description Defines an new user variable.
   * @param {VariableAction} variableAction
   * @return {this}
   */
  addVariable(variableAction) {
    return this.addAction(variableAction);
  }
  /**
   * @description Specifies a condition to be met before applying a transformation.
   * @param {ConditionalAction} conditionAction
   * @return {this}
   */
  conditional(conditionAction) {
    return this.addAction(conditionAction);
  }
  /**
   * @description Applies a filter or an effect on an asset.
   * @param {SimpleEffectAction} effectAction
   * @return {this}
   */
  effect(effectAction) {
    return this.addAction(effectAction);
  }
  /**
   * @description Applies adjustment effect on an asset.
   * @param action
   * @return {this}
   */
  adjust(action) {
    return this.addAction(action);
  }
  /**
   * @description Rotates the asset by the given angle.
   * @param {RotateAction} rotateAction
   * @return {this}
   */
  rotate(rotateAction) {
    return this.addAction(rotateAction);
  }
  /**
   * @description Applies a pre-defined named transformation of the given name.
   * @param {NamedTransformation} namedTransformation
   * @return {this}
   */
  namedTransformation(namedTransformation) {
    return this.addAction(namedTransformation);
  }
  /**
   * @description Applies delivery action.
   * @param deliveryAction
   * @return {this}
   */
  delivery(deliveryAction) {
    return this.addAction(deliveryAction);
  }
  /**
   * @description Sets the color of the background.
   * @param {Qualifiers.Color} color
   * @return {this}
   */
  backgroundColor(color2) {
    return this.addAction(new BackgroundColor(prepareColor(color2)));
  }
  /**
   * @description Adds a layer in a Photoshop document.
   * @param action
   * @return {this}
   */
  psdTools(action) {
    return this.addAction(action);
  }
  /**
   * @description Extracts an image or a page using an index, a range, or a name from a layered media asset.
   * @param action
   * @return {this}
   */
  extract(action) {
    return this.addAction(action);
  }
  /**
   * @description Adds a flag as a separate action.
   * @param {Qualifiers.Flag | string} flagQualifier
   * @return {this}
   */
  addFlag(flagQualifier) {
    const action = new Action();
    let flagToAdd = flagQualifier;
    if (typeof flagQualifier === "string") {
      flagToAdd = new FlagQualifier(flagQualifier);
    }
    action.addQualifier(flagToAdd);
    return this.addAction(action);
  }
  /**
   * @description Inject a custom function into the image transformation pipeline.
   * @return {this}
   */
  customFunction(customFunction) {
    return this.addAction(customFunction);
  }
  /**
   * Transcodes the video (or audio) to another format.
   * @param {Action} action
   * @return {this}
   */
  transcode(action) {
    return this.addAction(action);
  }
  /**
   * Applies the specified video edit action.
   *
   * @param {videoEditType} action
   * @return {this}
   */
  videoEdit(action) {
    return this.addAction(action);
  }
  toJson() {
    const actions = [];
    for (const action of this.actions) {
      const json = action.toJson();
      if (isErrorObject(json)) {
        return json;
      }
      actions.push(json);
    }
    return { actions };
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/ConcatenateAction.js
var ConcatenateAction = class extends Action {
  /**
   *
   * @param {Qualifiers.Source.VideoSource | Qualifiers.Source.ImageSource | Qualifiers.Source.FetchSource} source
   *         the Source to concatenate
   */
  constructor(source3) {
    super();
    this._actionModel = {
      actionType: "concatenate",
      source: source3.toJson()
    };
    this.concatSource = source3;
  }
  /**
   * @description Sets the transition between a video and a concatenated source
   * @param {Qualifiers.Transition.VideoSource} source The source to concatenate.
   * @return {this}
   */
  transition(source3) {
    this._actionModel.transition = source3.toJson();
    this._transition = source3;
    return this;
  }
  /**
   * @description Prepend the concatenated video - Adds the video before the original
   * @return {this}
   */
  prepend() {
    this._actionModel.prepend = true;
    this._prepend = true;
    return this;
  }
  /**
   * The duration in seconds
   * @param {number} sec
   * @return {this}
   */
  duration(sec) {
    this._actionModel.duration = sec;
    this._duration = sec;
    return this;
  }
  /**
   * @description Get the transitionString for the toString() method
   * @return {string}
   */
  getTransitionString() {
    const transTx = this._transition.getTransformation();
    return [
      `e_transition,${this._transition.getOpenSourceString("l")}`,
      transTx && transTx.toString(),
      "fl_layer_apply"
    ].filter((a) => a).join("/");
  }
  /**
   * @description Get the string representation of the Concatenation action
   */
  toString() {
    const open = [
      this._duration && `du_${this._duration}`,
      !this._transition && `fl_splice`,
      `${this.concatSource.getOpenSourceString("l")}`
    ].filter((a) => a).join(",");
    const close = [
      "fl_layer_apply",
      this._prepend && "so_0"
    ].filter((a) => a).join(",");
    let concatSourceTx;
    if (this.concatSource.getTransformation()) {
      concatSourceTx = this.concatSource.getTransformation();
    } else {
      concatSourceTx = new Transformation();
    }
    if (this._transition) {
      concatSourceTx.addTransformation(this.getTransitionString());
    }
    return [
      open,
      concatSourceTx.toString(),
      close
    ].filter((a) => a).join("/");
  }
  static fromJson(actionModel, transformationFromJson) {
    const { source: source3, transition: transition2, prepend, duration } = actionModel;
    const sourceInstance = createSourceFromModel(source3, transformationFromJson);
    const result = new this(sourceInstance);
    if (transition2) {
      result.transition(VideoSource.fromJson(transition2, transformationFromJson));
    }
    if (prepend) {
      result.prepend();
    }
    if (duration) {
      result.duration(duration);
    }
    return result;
  }
};
var ConcatenateAction_default = ConcatenateAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/VolumeAction.js
var VolumeAction = class extends Action {
  constructor(volumeValue) {
    super();
    let volumeValueModel = { mode: "mute" };
    if (volumeValue !== "mute") {
      volumeValueModel = {
        mode: `${volumeValue}`.endsWith("db") ? "decibels" : "percent",
        value: +`${volumeValue}`.replace("db", "")
      };
    }
    this._actionModel = {
      actionType: "volume",
      volumeValue: volumeValueModel
    };
    const qualifierValue = new QualifierValue(["volume", volumeValue]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
  }
  static fromJson(actionModel) {
    const { volumeValue } = actionModel;
    const { mode: mode2 } = volumeValue;
    const value = mode2 === "mute" ? mode2 : volumeValue.value;
    const suffix = mode2 === "mute" || mode2 === "percent" ? "" : "db";
    return new this(`${value}${suffix}`);
  }
};
var VolumeAction_default = VolumeAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit/PreviewAction.js
var PreviewAction = class extends Action {
  constructor() {
    super();
    this._actionModel = {
      actionType: "preview"
    };
  }
  /**
   * @description Control the duration of the video segments
   * @param {string|number} minSegDuration The duration of a video segment
   * @return {this}
   */
  minimumSegmentDuration(minSegDuration) {
    this._actionModel.minimumSegmentDuration = +minSegDuration;
    this._minSeg = minSegDuration;
    return this;
  }
  /**
   * @description Control the number of the video segments
   * @param {string|number} maxSeg The number of the video segments.
   * @return {this}
   */
  maximumSegments(maxSeg) {
    this._actionModel.maximumSegments = +maxSeg;
    this._maxSeg = maxSeg;
    return this;
  }
  /**
   * @description control the length of the generated preview
   * @param {string|number} duration The duration in seconds such as 1.2, or 5.0
   * @return {this}
   */
  duration(duration) {
    this._actionModel.duration = +duration;
    this._duration = duration;
    return this;
  }
  toString() {
    return [
      "e_preview",
      this._duration && `duration_${toFloatAsString(this._duration)}`,
      this._maxSeg && `max_seg_${this._maxSeg}`,
      this._minSeg && `min_seg_dur_${toFloatAsString(this._minSeg)}`
    ].filter((a) => a).join(":");
  }
  static fromJson(actionModel) {
    const { duration, maximumSegments, minimumSegmentDuration } = actionModel;
    const result = new this();
    if (duration != null) {
      result.duration(duration);
    }
    if (maximumSegments != null) {
      result.maximumSegments(maximumSegments);
    }
    if (minimumSegmentDuration != null) {
      result.minimumSegmentDuration(minimumSegmentDuration);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/videoEdit.js
function concatenate(source3) {
  return new ConcatenateAction_default(source3);
}
function trim() {
  return new TrimAction_default();
}
function volume(volumeValue) {
  return new VolumeAction_default(volumeValue);
}
function preview() {
  return new PreviewAction();
}
var VideoEdit = { concatenate, trim, volume, preview };

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/BitRateAction.js
var BitRateAction = class extends Action {
  constructor(bitRate2) {
    super();
    this.isConstant = false;
    this._actionModel = { actionType: "bitRate" };
    this.bitRate = bitRate2;
    this._actionModel.bitRate = bitRate2;
  }
  /**
   * @description video plays with a constant bitrate (CBR).
   */
  constant() {
    this.isConstant = true;
    this._actionModel.constant = true;
    return this;
  }
  prepareQualifiers() {
    let qualifierValue;
    if (this.isConstant) {
      qualifierValue = new QualifierValue([this.bitRate, "constant"]).setDelimiter(":");
    } else {
      qualifierValue = new QualifierValue(this.bitRate);
    }
    this.addQualifier(new Qualifier("br", qualifierValue));
    return this;
  }
  static fromJson(actionModel) {
    const { bitRate: bitRate2, constant } = actionModel;
    const result = new this(bitRate2);
    constant && result.constant();
    return result;
  }
};
var BitRateAction_default = BitRateAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/AudioCodecAction.js
var AudioCodecAction = class extends Action {
  constructor(codec) {
    super();
    this._actionModel = { actionType: "audioCodec" };
    this.addQualifier(new Qualifier("ac", codec));
    this._actionModel.audioCodec = codec;
  }
  static fromJson(actionModel) {
    const { audioCodec: audioCodec2 } = actionModel;
    const result = new this(audioCodec2);
    return result;
  }
};
var AudioCodecAction_default = AudioCodecAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/AudioFrequencyAction.js
var AudioFrequencyAction = class extends Action {
  constructor(freq) {
    super();
    this._actionModel = { actionType: "audioFrequency" };
    this.addQualifier(new Qualifier("af", freq));
    this._actionModel.audioFrequencyType = freq;
  }
  static fromJson(actionModel) {
    const { audioFrequencyType } = actionModel;
    const result = new this(audioFrequencyType.replace("freq", ""));
    return result;
  }
};
var AudioFrequencyAction_default = AudioFrequencyAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/FPSRangeAction.js
var FPSRangeAction = class extends Action {
  constructor(from, to) {
    super();
    this._actionModel = {};
    this.from = from;
    this._actionModel = {
      actionType: "fps",
      fps: { from }
    };
    if (to != null) {
      this.to = to;
      this._actionModel.fps.to = to;
    }
  }
  prepareQualifiers() {
    let qualifierValue;
    if (this.from && this.to) {
      qualifierValue = new QualifierValue(`${this.from}-${this.to}`);
    } else {
      qualifierValue = new QualifierValue(`${this.from}-`);
    }
    this.addQualifier(new Qualifier("fps", qualifierValue));
    return this;
  }
};
var FPSRangeAction_default = FPSRangeAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/FPSAction.js
var FPSAction = class extends Action {
  constructor(from) {
    super();
    this._actionModel = { actionType: "fps" };
    this._actionModel.fps = from;
    this.addQualifier(new Qualifier("fps", from));
  }
  static fromJson(actionModel) {
    const { fps: fps2 } = actionModel;
    let result;
    if (typeof fps2 === "object") {
      result = new FPSRangeAction_default(fps2.from, fps2.to);
    } else {
      result = new this(fps2);
    }
    return result;
  }
};
var FPSAction_default = FPSAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/KeyframeIntervalsAction.js
var KeyframeIntervalsAction = class extends Action {
  constructor(interval) {
    super();
    this._actionModel = { actionType: "keyframeInterval" };
    this._actionModel.interval = interval;
    this.addQualifier(new Qualifier("ki", toFloatAsString(interval)));
  }
  static fromJson(actionModel) {
    const { interval } = actionModel;
    const result = new this(interval);
    return result;
  }
};
var KeyframeIntervalsAction_default = KeyframeIntervalsAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/StreamingProfile.js
var StreamingProfileAction = class extends Action {
  constructor(profile) {
    super();
    this._actionModel = { actionType: "streamingProfile" };
    this.addQualifier(new Qualifier("sp", profile));
    this._actionModel.profile = STREAMING_PROFILE_TO_ACTION_TYPE_MAP[profile] || profile;
  }
  static fromJson(actionModel) {
    const { profile } = actionModel;
    const profileType = ACTION_TYPE_TO_STREAMING_PROFILE_MODE_MAP[profile] || profile;
    const result = new this(profileType);
    return result;
  }
};
var StreamingProfile_default = StreamingProfileAction;

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/ToAnimatedAction.js
var ToAnimatedAction = class extends Action {
  constructor(animatedFormat = "") {
    super();
    this._actionModel = { actionType: "toAnimated" };
    if (animatedFormat.toString() === "webp") {
      this.addFlag(animatedWebP());
    }
    this.addFlag(animated());
    if (animatedFormat) {
      this.addQualifier(new Qualifier("f", animatedFormat));
    }
    this._actionModel.animatedFormat = animatedFormat;
  }
  /**
   * @description Sets the time between frames.
   * @param delayValue The time in milliseconds.
   */
  delay(delayValue) {
    this.addQualifier(new Qualifier("dl", delayValue));
    this._actionModel.delay = delayValue;
    return this;
  }
  /**
   * @description Sets the frequency at which the video is sampled.
   * @param sampling As a string (e.g. '2.3s'), samples one frame every 2.3 seconds.<br>As a number (e.g. 20),
   * samples that many equally spaced frames over the duration of the video.
   */
  sampling(sampling) {
    this.addQualifier(new Qualifier("vs", sampling));
    this._actionModel.sampling = sampling;
    return this;
  }
  static fromJson(actionModel) {
    const { animatedFormat, sampling, delay } = actionModel;
    const result = new this(animatedFormat);
    sampling && result.sampling(sampling);
    delay && result.delay(delay);
    return result;
  }
};
var ToAnimatedAction_default = ToAnimatedAction;

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/videoCodecType/VideoCodecType.js
var VideoCodecType = class extends Qualifier {
  constructor(type) {
    super("vc");
    this._type = type;
    this.addValue(type);
  }
  getType() {
    return this._type;
  }
};
var AdvVideoCodecType = class extends Qualifier {
  constructor(type) {
    super("vc");
    this._type = type;
  }
  getType() {
    return this._type;
  }
  /**
   * @description Specifies the profile to use with the h264 codec.
   * @param {Qualifiers.VideoCodecProfile | string} profile Sets the profile of the video codec
   * @example new AdvVideoCodecType('h264').profile(VideoCodecProfile.baseline())
   * @return this;
   */
  profile(profile) {
    this._prof = profile;
    return this;
  }
  getProfile() {
    return this._prof;
  }
  /**
   * @description Specifies the level to use with the h264 codec and specified profile.
   * @param {Qualifiers.VideoCodecLevel | number | string} lvl
   * @example new AdvVideoCodecType('h264').profile(VideoCodecLevel.baseline())
   * @return this;
   */
  level(lvl) {
    this._lvl = lvl;
    return this;
  }
  getLevel() {
    return this._lvl;
  }
  /**
   * @description returns a toString representation of this qualifier
   * @return string;
   */
  toString() {
    return `vc_${this._type}:${this._prof}:${this._lvl}`;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/videoCodec.js
function auto6() {
  return new VideoCodecType("auto");
}
function h264() {
  return new AdvVideoCodecType("h264");
}
function h265() {
  return new VideoCodecType("h265");
}
function proRes() {
  return new VideoCodecType("prores");
}
function theora() {
  return new VideoCodecType("theora");
}
function vp8() {
  return new VideoCodecType("vp8");
}
function vp9() {
  return new VideoCodecType("vp9");
}
var VIDEO_CODEC_TO_TRANSFORMATION = {
  "auto": auto6(),
  "h264": h264(),
  "h265": h265(),
  "prores": proRes(),
  "theora": theora(),
  "vp8": vp8(),
  "vp9": vp9()
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode/VideoCodecAction.js
var VideoCodecAction = class extends Action {
  constructor(videoCodecTypeQualifier) {
    super();
    this._actionModel = { actionType: "videoCodec" };
    this._actionModel.videoCodec = { videoCodecName: videoCodecTypeQualifier.getType() };
    if (videoCodecTypeQualifier instanceof AdvVideoCodecType) {
      if (videoCodecTypeQualifier.getProfile()) {
        this._actionModel.videoCodec = Object.assign({ profile: videoCodecTypeQualifier.getProfile() }, this._actionModel.videoCodec);
      }
      if (videoCodecTypeQualifier.getLevel()) {
        this._actionModel.videoCodec = Object.assign({ level: videoCodecTypeQualifier.getLevel() }, this._actionModel.videoCodec);
      }
    }
    this.addQualifier(videoCodecTypeQualifier);
  }
  static fromJson(actionModel) {
    const { videoCodec: videoCodec2 } = actionModel;
    const result = new this(VIDEO_CODEC_TO_TRANSFORMATION[videoCodec2.videoCodecName]);
    videoCodec2.profile && new this(VIDEO_CODEC_TO_TRANSFORMATION[videoCodec2.videoCodecName].profile(videoCodec2.profile));
    videoCodec2.level && new this(VIDEO_CODEC_TO_TRANSFORMATION[videoCodec2.videoCodecName].level(videoCodec2.level));
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/transcode.js
function audioFrequency(freq) {
  return new AudioFrequencyAction_default(freq);
}
function audioCodec(codec) {
  return new AudioCodecAction_default(codec);
}
function bitRate(bitRate2) {
  return new BitRateAction_default(bitRate2);
}
function fps(from) {
  return new FPSAction_default(from);
}
function fpsRange(from, to) {
  return new FPSRangeAction_default(from, to);
}
function keyframeInterval(interval) {
  return new KeyframeIntervalsAction_default(interval);
}
function streamingProfile(profile) {
  return new StreamingProfile_default(profile);
}
function toAnimated(animatedFormat = "") {
  return new ToAnimatedAction_default(animatedFormat);
}
function videoCodec(videoCodecType) {
  return new VideoCodecAction(videoCodecType);
}
var Transcode = { bitRate, audioCodec, audioFrequency, fps, fpsRange, keyframeInterval, streamingProfile, toAnimated, videoCodec };

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools/ClipAction.js
var ClipAction = class extends Action {
  constructor() {
    super();
    this.isEvenOdd = false;
  }
  /**
   * @description The name of the path to clip by
   * @param {string} path
   * @return {this}
   */
  byName(path) {
    this.path = path;
    return this;
  }
  /**
   * @description The index of the path to clip by
   * @param {number} path
   * @return {this}
   */
  byIndex(path) {
    this.path = path;
    return this;
  }
  /**
   * @description Trims pixels according to a clipping path included in the original image using an evenodd clipping rule.
   * @return {this}
   */
  evenOdd() {
    this.isEvenOdd = true;
    return this;
  }
  prepareQualifiers() {
    let qualifierValue;
    if (typeof this.path === "string") {
      qualifierValue = new QualifierValue(["name", this.path]).setDelimiter(":");
    } else {
      qualifierValue = new QualifierValue(this.path);
    }
    if (this.isEvenOdd) {
      this.addFlag(clipEvenOdd());
    } else {
      this.addFlag(clip());
    }
    this.addQualifier(new Qualifier("pg", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools/GetLayerAction.js
var GetLayerAction = class extends Action {
  constructor() {
    super();
    this.qualifierValue = new QualifierValue();
    this.qualifierValue.delimiter = ";";
  }
  /**
   * @description deliver an image containing only specified layer of a Photoshop image from The layer index
   * @param {string|number} from the index of the layer
   */
  byIndex(from) {
    this.qualifierValue.addValue(from);
    return this;
  }
  /**
   * @description deliver an image containing only specified range of layers of a Photoshop image
   * @param {string|number} from The layer number
   * @param {string|number} to The layer number
   */
  byRange(from, to) {
    const range = new QualifierValue(from);
    range.addValue(to);
    range.delimiter = "-";
    this.qualifierValue.addValue(range);
    return this;
  }
  /**
   * @description deliver an image containing only specified layer by name of a Photoshop image
   * @param {string|number} name The layer by name
   */
  byName(name2) {
    this.name = name2;
    this.qualifierValue.addValue(name2);
    return this;
  }
  prepareQualifiers() {
    let qualifierValue = this.qualifierValue;
    if (this.name) {
      qualifierValue = new QualifierValue(["name", this.qualifierValue]).setDelimiter(":");
    }
    this.addQualifier(new Qualifier("pg", qualifierValue));
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools/SmartObjectAction.js
var SmartObjectAction = class extends Action {
  constructor() {
    super();
    this.qualifierValue = new QualifierValue();
    this.useName = false;
    this.qualifierValue.delimiter = ";";
  }
  /**
   * @description Creates a new instance using the specified number.
   * @param index The number.
   */
  byIndex(index) {
    this.smartObjectValue = index;
    this.qualifierValue.addValue(index);
    return this;
  }
  /**
   * @description Creates an instance using the name.
   * @param {string} layerName The name of the layer
   */
  byLayerName(layerName) {
    this.useName = true;
    this.qualifierValue.addValue(layerName);
    return this;
  }
  prepareQualifiers() {
    let qualifierValue;
    if (this.useName) {
      qualifierValue = new QualifierValue(["embedded:name", this.qualifierValue]);
    } else {
      qualifierValue = new QualifierValue(["embedded", this.qualifierValue]);
    }
    this.addQualifier(new Qualifier("pg", qualifierValue));
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/actions/psdTools.js
function clip2() {
  return new ClipAction();
}
function getLayer() {
  return new GetLayerAction();
}
function smartObject() {
  return new SmartObjectAction();
}
var PSDTools = { clip: clip2, getLayer, smartObject };

// node_modules/@cloudinary/transformation-builder-sdk/actions/animated.js
var AnimatedAction = class extends Action {
  constructor() {
    super();
  }
  /**
   * @description Controls the time delay between the frames of an animated image, in milliseconds.
   * @param {number} delayValue The delay in milliseconds
   * @return {this}
   */
  delay(delayValue) {
    this.addQualifier(new Qualifier("dl", delayValue));
    return this;
  }
  /**
   * @description Delivers an animated GIF that contains additional loops of the GIF.
   * @param {number} additionalLoops The additional number of times to play the animated GIF.
   * @return {this}
   */
  loop(additionalLoops) {
    const qualifierValue = new QualifierValue(["loop", additionalLoops]).setDelimiter(":");
    this.addQualifier(new Qualifier("e", qualifierValue));
    return this;
  }
};
function edit() {
  return new AnimatedAction();
}
var Animated = {
  edit
};

export {
  DeliveryFormatAction,
  Transformation,
  Gravity,
  TextDecoration,
  TextAlignment,
  Stroke,
  StreamingProfile,
  SimulateColorBlind,
  RotationMode,
  Region,
  Quality,
  PositionQualifier,
  OutlineMode,
  ImproveMode,
  GradientDirection,
  Format,
  FontWeight,
  FontStyle,
  FontHinting,
  Expression,
  Dither,
  ColorSpace,
  Color,
  Background,
  AudioFrequency,
  AudioCodec,
  AspectRatio,
  ArtisticFilter,
  AnimatedFormat,
  ChromaSubSampling,
  Dpr,
  Source,
  GradientFade,
  scale,
  imaggaScale,
  imaggaCrop,
  crop,
  fill2 as fill,
  fit,
  pad,
  limitFill,
  limitFit,
  minimumPad,
  minimumFit,
  fillPad,
  thumbnail,
  limitPad,
  Resize,
  Border,
  RoundCorners,
  Effect,
  Rotate,
  Adjust,
  Overlay,
  Underlay,
  NamedTransformation,
  Delivery,
  CustomFunction,
  VideoEdit,
  Transcode,
  PSDTools,
  Animated
};
//# sourceMappingURL=chunk-4YPBZXLV.js.map
